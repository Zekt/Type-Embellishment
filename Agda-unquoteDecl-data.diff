From 611271b2260a5a4ec35547cecc6b24c72410c1fc Mon Sep 17 00:00:00 2001
From: Liang-Ting Chen <liang.ting.chen.tw@gmail.com>
Date: Thu, 12 Aug 2021 21:10:19 +0800
Subject: [PATCH] [ new ] Add a new concrete syntax `UnquoteDecl` for unquoting
 data type declaration

---
 .../Interaction/Highlighting/FromAbstract.hs  |   1 +
 src/full/Agda/Syntax/Abstract.hs              |   3 +
 src/full/Agda/Syntax/Abstract/Views.hs        |   2 +
 src/full/Agda/Syntax/Concrete.hs              |   4 +
 src/full/Agda/Syntax/Concrete/Definitions.hs  |  54 ++--
 .../Agda/Syntax/Concrete/Definitions/Types.hs |   6 +-
 src/full/Agda/Syntax/Concrete/Fixity.hs       |  62 ++---
 src/full/Agda/Syntax/Concrete/Generic.hs      |   1 +
 src/full/Agda/Syntax/Concrete/Pretty.hs       | 239 +++++++++---------
 src/full/Agda/Syntax/Parser/Parser.y          |   3 +
 .../Syntax/Translation/AbstractToConcrete.hs  |   2 +
 .../Syntax/Translation/ConcreteToAbstract.hs  |  52 ++++
 src/full/Agda/Termination/TermCheck.hs        |   1 +
 src/full/Agda/TypeChecking/Rules/Decl.hs      |   5 +
 14 files changed, 263 insertions(+), 172 deletions(-)

diff --git a/src/full/Agda/Interaction/Highlighting/FromAbstract.hs b/src/full/Agda/Interaction/Highlighting/FromAbstract.hs
index 1d5a322aa..76bbefbd5 100644
--- a/src/full/Agda/Interaction/Highlighting/FromAbstract.hs
+++ b/src/full/Agda/Interaction/Highlighting/FromAbstract.hs
@@ -214,6 +214,7 @@ instance Hilite A.Declaration where
       A.PatternSynDef x xs p                 -> hl x <> hl xs <> hl p
       A.UnquoteDecl _mi _di xs e             -> hl xs <> hl e
       A.UnquoteDef _di xs e                  -> hl xs <> hl e
+      A.UnquoteData _i xs _uc _j cs e        -> hl xs <> hl cs <> hl e
       A.ScopedDecl s ds                      -> hl ds
       A.Pragma _r pragma                     -> hl pragma
     where
diff --git a/src/full/Agda/Syntax/Abstract.hs b/src/full/Agda/Syntax/Abstract.hs
index 4fa6cb0e3..a7f18b16b 100644
--- a/src/full/Agda/Syntax/Abstract.hs
+++ b/src/full/Agda/Syntax/Abstract.hs
@@ -189,6 +189,7 @@ data Declaration
       -- ^ Only for highlighting purposes
   | UnquoteDecl MutualInfo [DefInfo] [QName] Expr
   | UnquoteDef  [DefInfo] [QName] Expr
+  | UnquoteData [DefInfo] [QName] UniverseCheck [DefInfo] [QName] Expr
   | ScopedDecl ScopeInfo [Declaration]  -- ^ scope annotation
   deriving (Data, Show, Generic)
 
@@ -666,6 +667,7 @@ instance HasRange Declaration where
     getRange (PatternSynDef x _ _   ) = getRange x
     getRange (UnquoteDecl _ i _ _)    = getRange i
     getRange (UnquoteDef i _ _)       = getRange i
+    getRange (UnquoteData i _ _ j _ _) = getRange (i, j)
 
 instance HasRange (Pattern' e) where
     getRange (VarP x)           = getRange x
@@ -799,6 +801,7 @@ instance KillRange Declaration where
   killRange (PatternSynDef x xs p     ) = killRange3 PatternSynDef x xs p
   killRange (UnquoteDecl mi i x e     ) = killRange4 UnquoteDecl mi i x e
   killRange (UnquoteDef i x e         ) = killRange3 UnquoteDef i x e
+  killRange (UnquoteData i xs uc j cs e) = killRange6 UnquoteData i xs uc j cs e
 
 instance KillRange ModuleApplication where
   killRange (SectionApp a b c  ) = killRange3 SectionApp a b c
diff --git a/src/full/Agda/Syntax/Abstract/Views.hs b/src/full/Agda/Syntax/Abstract/Views.hs
index 67190f798..4dc9ed7bf 100644
--- a/src/full/Agda/Syntax/Abstract/Views.hs
+++ b/src/full/Agda/Syntax/Abstract/Views.hs
@@ -428,6 +428,7 @@ instance ExprLike Declaration where
       PatternSynDef f xs p      -> PatternSynDef f xs <$> rec p
       UnquoteDecl i is xs e     -> UnquoteDecl i is xs <$> rec e
       UnquoteDef i xs e         -> UnquoteDef i xs <$> rec e
+      UnquoteData i xs uc j cs e -> UnquoteData i xs uc j cs <$> rec e
       ScopedDecl s ds           -> ScopedDecl s <$> rec ds
     where
       rec :: RecurseExprRecFn m
@@ -490,6 +491,7 @@ instance DeclaredNames Declaration where
       PatternSynDef q _ _          -> singleton (WithKind PatternSynName q)
       UnquoteDecl _ _ qs _         -> fromList $ map (WithKind OtherDefName) qs  -- could be Fun or Axiom
       UnquoteDef _ qs _            -> fromList $ map (WithKind FunName) qs       -- cannot be Axiom
+      UnquoteData _ xs _ _ cs _    -> fromList $ map (WithKind DataName) xs ++ map (WithKind ConName) cs
       FunDef _ q _ cls             -> singleton (WithKind FunName q) <> declaredNames cls
       ScopedDecl _ decls           -> declaredNames decls
       Section _ _ _ decls          -> declaredNames decls
diff --git a/src/full/Agda/Syntax/Concrete.hs b/src/full/Agda/Syntax/Concrete.hs
index d256b8fc5..54bf6e5ce 100644
--- a/src/full/Agda/Syntax/Concrete.hs
+++ b/src/full/Agda/Syntax/Concrete.hs
@@ -482,6 +482,7 @@ data Declaration
       -- ^ @unquoteDecl xs = e@
   | UnquoteDef  Range [Name] Expr
       -- ^ @unquoteDef xs = e@
+  | UnquoteData Range [Name] [Name] Expr
   | Pragma      Pragma
   deriving (Data, Eq)
 
@@ -905,6 +906,7 @@ instance HasRange Declaration where
   getRange (PatternSyn r _ _ _)    = r
   getRange (UnquoteDecl r _ _)     = r
   getRange (UnquoteDef r _ _)      = r
+  getRange (UnquoteData r _ _ _)   = r
   getRange (Pragma p)              = getRange p
 
 instance HasRange LHS where
@@ -1052,6 +1054,7 @@ instance KillRange Declaration where
   killRange (Module _ q t d)        = killRange3 (Module noRange) q t d
   killRange (UnquoteDecl _ x t)     = killRange2 (UnquoteDecl noRange) x t
   killRange (UnquoteDef _ x t)      = killRange2 (UnquoteDef noRange) x t
+  killRange (UnquoteData _ xs cs t) = killRange3 (UnquoteData noRange) xs cs t
   killRange (Pragma p)              = killRange1 Pragma p
 
 instance KillRange Expr where
@@ -1267,6 +1270,7 @@ instance NFData Declaration where
   rnf (Module _ a b c)        = rnf a `seq` rnf b `seq` rnf c
   rnf (UnquoteDecl _ a b)     = rnf a `seq` rnf b
   rnf (UnquoteDef _ a b)      = rnf a `seq` rnf b
+  rnf (UnquoteData _ a b c)   = rnf a `seq` rnf b `seq` rnf c
   rnf (Pragma a)              = rnf a
 
 instance NFData OpenShortHand
diff --git a/src/full/Agda/Syntax/Concrete/Definitions.hs b/src/full/Agda/Syntax/Concrete/Definitions.hs
index acb4be2d9..0717c5248 100644
--- a/src/full/Agda/Syntax/Concrete/Definitions.hs
+++ b/src/full/Agda/Syntax/Concrete/Definitions.hs
@@ -150,27 +150,28 @@ data DeclKind
   deriving (Eq, Show)
 
 declKind :: NiceDeclaration -> DeclKind
-declKind (FunSig r _ _ _ _ _ tc cc x _)     = LoneSigDecl r (FunName tc cc) x
-declKind (NiceRecSig r _ _ pc uc x pars _)  = LoneSigDecl r (RecName pc uc) x
-declKind (NiceDataSig r _ _ pc uc x pars _) = LoneSigDecl r (DataName pc uc) x
-declKind (FunDef r _ abs ins tc cc x _)     = LoneDefs (FunName tc cc) [x]
-declKind (NiceDataDef _ _ _ pc uc x pars _) = LoneDefs (DataName pc uc) [x]
+declKind (FunSig r _ _ _ _ _ tc cc x _)      = LoneSigDecl r (FunName tc cc) x
+declKind (NiceRecSig r _ _ pc uc x pars _)   = LoneSigDecl r (RecName pc uc) x
+declKind (NiceDataSig r _ _ pc uc x pars _)  = LoneSigDecl r (DataName pc uc) x
+declKind (FunDef r _ abs ins tc cc x _)      = LoneDefs (FunName tc cc) [x]
+declKind (NiceDataDef _ _ _ pc uc x pars _)  = LoneDefs (DataName pc uc) [x]
+declKind (NiceUnquoteData _ _ _ pc uc xs _ _) = LoneDefs (DataName pc uc) xs
 declKind (NiceRecDef _ _ _ pc uc x _ pars _) = LoneDefs (RecName pc uc) [x]
-declKind (NiceUnquoteDef _ _ _ tc cc xs _)  = LoneDefs (FunName tc cc) xs
-declKind Axiom{}                            = OtherDecl
-declKind NiceField{}                        = OtherDecl
-declKind PrimitiveFunction{}                = OtherDecl
-declKind NiceMutual{}                       = OtherDecl
-declKind NiceModule{}                       = OtherDecl
-declKind NiceModuleMacro{}                  = OtherDecl
-declKind NiceOpen{}                         = OtherDecl
-declKind NiceImport{}                       = OtherDecl
-declKind NicePragma{}                       = OtherDecl
-declKind NiceFunClause{}                    = OtherDecl
-declKind NicePatternSyn{}                   = OtherDecl
-declKind NiceGeneralize{}                   = OtherDecl
-declKind NiceUnquoteDecl{}                  = OtherDecl
-declKind NiceLoneConstructor{}              = OtherDecl
+declKind (NiceUnquoteDef _ _ _ tc cc xs _)   = LoneDefs (FunName tc cc) xs
+declKind Axiom{}                             = OtherDecl
+declKind NiceField{}                         = OtherDecl
+declKind PrimitiveFunction{}                 = OtherDecl
+declKind NiceMutual{}                        = OtherDecl
+declKind NiceModule{}                        = OtherDecl
+declKind NiceModuleMacro{}                   = OtherDecl
+declKind NiceOpen{}                          = OtherDecl
+declKind NiceImport{}                        = OtherDecl
+declKind NicePragma{}                        = OtherDecl
+declKind NiceFunClause{}                     = OtherDecl
+declKind NicePatternSyn{}                    = OtherDecl
+declKind NiceGeneralize{}                    = OtherDecl
+declKind NiceUnquoteDecl{}                   = OtherDecl
+declKind NiceLoneConstructor{}               = OtherDecl
 
 -- | Replace (Data/Rec/Fun)Sigs with Axioms for postulated names
 --   The first argument is a list of axioms only.
@@ -492,6 +493,11 @@ niceDeclarations fixs ds = do
               mapM_ removeLoneSig xs
               return ([NiceUnquoteDef r PublicAccess ConcreteDef TerminationCheck YesCoverageCheck xs e] , ds)
 
+        UnquoteData r xs cs e -> do
+          pc <- use positivityCheckPragma
+          uc <- use universeCheckPragma
+          return ([NiceUnquoteData r PublicAccess ConcreteDef pc uc xs cs e], ds)
+
         Pragma p -> nicePragma p ds
 
     nicePragma :: Pragma -> [Declaration] -> Nice ([NiceDeclaration], [Declaration])
@@ -1036,6 +1042,7 @@ niceDeclarations fixs ds = do
             NiceGeneralize{}    -> top
             NiceUnquoteDecl{}   -> top
             NiceUnquoteDef{}    -> bottom
+            NiceUnquoteData{}   -> top
             NicePragma r pragma -> case pragma of
 
               OptionsPragma{}           -> top     -- error thrown in the type checker
@@ -1139,6 +1146,7 @@ niceDeclarations fixs ds = do
         termCheck NicePatternSyn{}    = TerminationCheck
         termCheck NiceGeneralize{}    = TerminationCheck
         termCheck NiceLoneConstructor{} = TerminationCheck
+        termCheck NiceUnquoteData{}   = TerminationCheck
 
         covCheck :: NiceDeclaration -> CoverageCheck
         covCheck (FunSig _ _ _ _ _ _ _ cc _ _)      = cc
@@ -1163,6 +1171,7 @@ niceDeclarations fixs ds = do
         covCheck NicePatternSyn{}    = YesCoverageCheck
         covCheck NiceGeneralize{}    = YesCoverageCheck
         covCheck NiceLoneConstructor{} = YesCoverageCheck
+        covCheck NiceUnquoteData{}   = YesCoverageCheck 
 
         -- ASR (26 December 2015): Do not positivity check a mutual
         -- block if any of its inner declarations comes with a
@@ -1231,6 +1240,7 @@ niceDeclarations fixs ds = do
         d@NiceRecDef{}                 -> return d
         d@NicePatternSyn{}             -> return d
         d@NiceGeneralize{}             -> return d
+        d@NiceUnquoteData{}            -> return d
 
     setInstance
       :: Range  -- Range of @instance@ keyword.
@@ -1294,6 +1304,7 @@ instance MakeAbstract NiceDeclaration where
       -- Need to set updater state to dirty!
       NiceUnquoteDecl r p _ i tc cc x e -> tellDirty $> NiceUnquoteDecl r p AbstractDef i tc cc x e
       NiceUnquoteDef r p _ tc cc x e    -> tellDirty $> NiceUnquoteDef r p AbstractDef tc cc x e
+      NiceUnquoteData r p _ tc cc x xs e -> tellDirty $> NiceUnquoteData r p AbstractDef tc cc x xs e
       d@NiceModule{}                 -> return d
       d@NiceModuleMacro{}            -> return d
       d@NicePragma{}                 -> return d
@@ -1367,6 +1378,7 @@ instance MakePrivate NiceDeclaration where
       FunDef r ds a i tc cc x cls              -> FunDef r ds a i tc cc x <$> mkPrivate o cls
       d@NiceDataDef{}                          -> return d
       d@NiceRecDef{}                           -> return d
+      d@NiceUnquoteData{}                      -> return d
 
 instance MakePrivate Clause where
   mkPrivate o (Clause x catchall lhs rhs wh with) = do
@@ -1412,6 +1424,7 @@ notSoNiceDeclarations = \case
     NiceGeneralize r _ i tac n e   -> [Generalize r [TypeSig i tac n e]]
     NiceUnquoteDecl r _ _ i _ _ x e -> inst i [UnquoteDecl r x e]
     NiceUnquoteDef r _ _ _ _ x e    -> [UnquoteDef r x e]
+    NiceUnquoteData r _ _ _ _ x xs e  -> [UnquoteData r x xs e]
   where
     inst (InstanceDef r) ds = [InstanceB r ds]
     inst NotInstanceDef  ds = ds
@@ -1440,3 +1453,4 @@ niceHasAbstract = \case
     NiceGeneralize{}              -> Nothing
     NiceUnquoteDecl _ _ a _ _ _ _ _ -> Just a
     NiceUnquoteDef _ _ a _ _ _ _    -> Just a
+    NiceUnquoteData _ _ a _ _ _ _ _ -> Just a
diff --git a/src/full/Agda/Syntax/Concrete/Definitions/Types.hs b/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
index 572a79601..ad14a9744 100644
--- a/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
+++ b/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
@@ -80,6 +80,7 @@ data NiceDeclaration
   | NiceGeneralize Range Access ArgInfo TacticAttribute Name Expr
   | NiceUnquoteDecl Range Access IsAbstract IsInstance TerminationCheck CoverageCheck [Name] Expr
   | NiceUnquoteDef Range Access IsAbstract TerminationCheck CoverageCheck [Name] Expr
+  | NiceUnquoteData Range Access IsAbstract PositivityCheck UniverseCheck [Name] [Name] Expr
   deriving (Data, Show, Generic)
 
 instance NFData NiceDeclaration
@@ -215,7 +216,8 @@ instance HasRange NiceDeclaration where
   getRange (NiceGeneralize r _ _ _ _ _)    = r
   getRange (NiceFunClause r _ _ _ _ _ _)   = r
   getRange (NiceUnquoteDecl r _ _ _ _ _ _ _) = r
-  getRange (NiceUnquoteDef r _ _ _ _ _ _)    = r
+  getRange (NiceUnquoteDef r _ _ _ _ _ _)  = r
+  getRange (NiceUnquoteData r _ _ _ _ _ _ _) = r
 
 instance Pretty NiceDeclaration where
   pretty = \case
@@ -240,6 +242,7 @@ instance Pretty NiceDeclaration where
     NiceGeneralize _ _ _ _ x _     -> text "variable" <+> pretty x
     NiceUnquoteDecl _ _ _ _ _ _ xs _ -> text "<unquote declarations>"
     NiceUnquoteDef _ _ _ _ _ xs _    -> text "<unquote definitions>"
+    NiceUnquoteData _ _ _ _ _ x xs _ -> text "<unquote data types>"
 
 declName :: NiceDeclaration -> String
 declName Axiom{}             = "Postulates"
@@ -255,6 +258,7 @@ declName NicePatternSyn{}    = "Pattern synonyms"
 declName NiceGeneralize{}    = "Generalized variables"
 declName NiceUnquoteDecl{}   = "Unquoted declarations"
 declName NiceUnquoteDef{}    = "Unquoted definitions"
+declName NiceUnquoteData{}   = "Unquoted data types"
 declName NiceRecSig{}        = "Records"
 declName NiceDataSig{}       = "Data types"
 declName NiceFunClause{}     = "Functions without a type signature"
diff --git a/src/full/Agda/Syntax/Concrete/Fixity.hs b/src/full/Agda/Syntax/Concrete/Fixity.hs
index 47a2c4b79..effa6bedf 100644
--- a/src/full/Agda/Syntax/Concrete/Fixity.hs
+++ b/src/full/Agda/Syntax/Concrete/Fixity.hs
@@ -180,6 +180,7 @@ fixitiesAndPolarities' = foldMap $ \case
   Module          {}  -> mempty
   UnquoteDecl     {}  -> mempty
   UnquoteDef      {}  -> mempty
+  UnquoteData     {}  -> mempty
   Pragma          {}  -> mempty
 
 data DeclaredNames = DeclaredNames { _allNames, _postulates, _privateNames :: Set Name }
@@ -208,39 +209,40 @@ declaresName x = declaresNames [x]
 --   i.e., do not go into modules.
 declaredNames :: Declaration -> DeclaredNames
 declaredNames = \case
-  TypeSig _ _ x _      -> declaresName x
-  FieldSig _ _ x _     -> declaresName x
-  Field _ fs           -> foldMap declaredNames fs
+  TypeSig _ _ x _       -> declaresName x
+  FieldSig _ _ x _      -> declaresName x
+  Field _ fs            -> foldMap declaredNames fs
   FunClause (LHS p [] []) _ _ _
     | IdentP (QName x) <- removeParenP p
-                       -> declaresName x
-  FunClause{}          -> mempty
-  DataSig _ x _ _      -> declaresName x
-  DataDef _ _ _ cs     -> foldMap declaredNames cs
-  Data _ x _ _ cs      -> declaresName x <> foldMap declaredNames cs
-  RecordSig _ x _ _    -> declaresName x
-  RecordDef _ x d _ _  -> declaresNames $     foldMap (:[]) (fst <$> recConstructor d)
-  Record _ x d _ _ _   -> declaresNames $ x : foldMap (:[]) (fst <$> recConstructor d)
-  RecordDirective _    -> mempty
-  Infix _ _            -> mempty
-  Syntax _ _           -> mempty
-  PatternSyn _ x _ _   -> declaresName x
-  Mutual    _ ds       -> foldMap declaredNames ds
+                        -> declaresName x
+  FunClause{}           -> mempty
+  DataSig _ x _ _       -> declaresName x
+  DataDef _ _ _ cs      -> foldMap declaredNames cs
+  Data _ x _ _ cs       -> declaresName x <> foldMap declaredNames cs
+  RecordSig _ x _ _     -> declaresName x
+  RecordDef _ x d _ _   -> declaresNames $     foldMap (:[]) (fst <$> recConstructor d)
+  Record _ x d _ _ _    -> declaresNames $ x : foldMap (:[]) (fst <$> recConstructor d)
+  RecordDirective _     -> mempty
+  Infix _ _             -> mempty
+  Syntax _ _            -> mempty
+  PatternSyn _ x _ _    -> declaresName x
+  Mutual    _ ds        -> foldMap declaredNames ds
   InterleavedMutual    _ ds -> foldMap declaredNames ds
-  LoneConstructor _ ds -> foldMap declaredNames ds
-  Abstract  _ ds       -> foldMap declaredNames ds
-  Private _ _ ds       -> allPrivateNames $ foldMap declaredNames ds
-  InstanceB _ ds       -> foldMap declaredNames ds
-  Macro     _ ds       -> foldMap declaredNames ds
-  Postulate _ ds       -> allPostulates $ foldMap declaredNames ds
-  Primitive _ ds       -> foldMap declaredNames ds
-  Generalize _ ds      -> foldMap declaredNames ds
-  Open{}               -> mempty
-  Import{}             -> mempty
-  ModuleMacro{}        -> mempty
-  Module{}             -> mempty
-  UnquoteDecl _ xs _   -> declaresNames xs
-  UnquoteDef{}         -> mempty
+  LoneConstructor _ ds  -> foldMap declaredNames ds
+  Abstract  _ ds        -> foldMap declaredNames ds
+  Private _ _ ds        -> allPrivateNames $ foldMap declaredNames ds
+  InstanceB _ ds        -> foldMap declaredNames ds
+  Macro     _ ds        -> foldMap declaredNames ds
+  Postulate _ ds        -> allPostulates $ foldMap declaredNames ds
+  Primitive _ ds        -> foldMap declaredNames ds
+  Generalize _ ds       -> foldMap declaredNames ds
+  Open{}                -> mempty
+  Import{}              -> mempty
+  ModuleMacro{}         -> mempty
+  Module{}              -> mempty
+  UnquoteDecl _ xs _    -> declaresNames xs
+  UnquoteDef{}          -> mempty
+  UnquoteData _ xs cs _ -> declaresNames (xs ++ cs)
   -- BUILTIN pragmas which do not require an accompanying definition declare
   -- the (unqualified) name they mention.
   Pragma (BuiltinPragma _ b (QName x))
diff --git a/src/full/Agda/Syntax/Concrete/Generic.hs b/src/full/Agda/Syntax/Concrete/Generic.hs
index f36eb877b..e45c35c78 100644
--- a/src/full/Agda/Syntax/Concrete/Generic.hs
+++ b/src/full/Agda/Syntax/Concrete/Generic.hs
@@ -246,6 +246,7 @@ instance ExprLike Declaration where
      Module r n tel ds         -> Module r n (mapE tel)                $ mapE ds
      UnquoteDecl r x e         -> UnquoteDecl r x (mapE e)
      UnquoteDef r x e          -> UnquoteDef r x (mapE e)
+     UnquoteData r x xs e      -> UnquoteData r x xs (mapE e)
      e@Pragma{}                -> e
    where
      mapE :: ExprLike e => e -> e
diff --git a/src/full/Agda/Syntax/Concrete/Pretty.hs b/src/full/Agda/Syntax/Concrete/Pretty.hs
index 6bb12702b..8828a479b 100644
--- a/src/full/Agda/Syntax/Concrete/Pretty.hs
+++ b/src/full/Agda/Syntax/Concrete/Pretty.hs
@@ -386,128 +386,125 @@ instance Pretty DoStmt where
   pretty (DoLet _ ds) = "let" <+> vcat (fmap pretty ds)
 
 instance Pretty Declaration where
-    prettyList = vcat . map pretty
-    pretty d =
-        case d of
-            TypeSig i tac x e ->
-                sep [ prettyTactic' tac $ prettyRelevance i $ prettyCohesion i $ prettyQuantity i $ pretty x <+> ":"
-                    , nest 2 $ pretty e
-                    ]
-
-            FieldSig inst tac x (Arg i e) ->
-                mkInst inst $ mkOverlap i $
-                prettyRelevance i $ prettyHiding i id $ prettyCohesion i $ prettyQuantity i $
-                pretty $ TypeSig (setRelevance Relevant i) tac x e
-
-                where
-
-                  mkInst (InstanceDef _) d = sep [ "instance", nest 2 d ]
-                  mkInst NotInstanceDef  d = d
-
-                  mkOverlap i d | isOverlappable i = "overlap" <+> d
-                                | otherwise        = d
-
-            Field _ fs ->
-              sep [ "field"
-                  , nest 2 $ vcat (map pretty fs)
+  prettyList = vcat . map pretty
+  pretty = \case
+    TypeSig i tac x e ->
+      sep [ prettyTactic' tac $ prettyRelevance i $ prettyCohesion i $ prettyQuantity i $ pretty x <+> ":"
+          , nest 2 $ pretty e
+          ]
+    FieldSig inst tac x (Arg i e) ->
+      mkInst inst $ mkOverlap i $
+      prettyRelevance i $ prettyHiding i id $ prettyCohesion i $ prettyQuantity i $
+      pretty $ TypeSig (setRelevance Relevant i) tac x e
+      where
+        mkInst (InstanceDef _) d = sep [ "instance", nest 2 d ]
+        mkInst NotInstanceDef  d = d
+
+        mkOverlap i d | isOverlappable i = "overlap" <+> d
+                      | otherwise        = d
+    Field _ fs ->
+      sep [ "field"
+          , nest 2 $ vcat (map pretty fs)
+          ]
+    FunClause lhs rhs wh _ ->
+      sep [ pretty lhs
+          , nest 2 $ pretty rhs
+          ] $$ nest 2 (pretty wh)
+    DataSig _ x tel e ->
+      sep [ hsep  [ "data"
+                  , pretty x
+                  , fcat (map pretty tel)
                   ]
-            FunClause lhs rhs wh _ ->
-                sep [ pretty lhs
-                    , nest 2 $ pretty rhs
-                    ] $$ nest 2 (pretty wh)
-            DataSig _ x tel e ->
-                sep [ hsep  [ "data"
-                            , pretty x
-                            , fcat (map pretty tel)
-                            ]
-                    , nest 2 $ hsep
-                            [ ":"
-                            , pretty e
-                            ]
-                    ]
-            Data _ x tel e cs ->
-                sep [ hsep  [ "data"
-                            , pretty x
-                            , fcat (map pretty tel)
-                            ]
-                    , nest 2 $ hsep
-                            [ ":"
-                            , pretty e
-                            , "where"
-                            ]
-                    ] $$ nest 2 (vcat $ map pretty cs)
-            DataDef _ x tel cs ->
-                sep [ hsep  [ "data"
-                            , pretty x
-                            , fcat (map pretty tel)
-                            ]
-                    , nest 2 $ "where"
-                    ] $$ nest 2 (vcat $ map pretty cs)
-            RecordSig _ x tel e ->
-                sep [ hsep  [ "record"
-                            , pretty x
-                            , fcat (map pretty tel)
-                            ]
-                    , nest 2 $ hsep
-                            [ ":"
-                            , pretty e
-                            ]
-                    ]
-            Record _ x dir tel e cs ->
-              pRecord x dir tel (Just e) cs
-            RecordDef _ x dir tel cs ->
-              pRecord x dir tel Nothing cs
-            RecordDirective r -> pRecordDirective r
-            Infix f xs  ->
-                pretty f <+> fsep (punctuate comma $ fmap pretty xs)
-            Syntax n xs -> "syntax" <+> pretty n <+> "..."
-            PatternSyn _ n as p -> "pattern" <+> pretty n <+> fsep (map pretty as)
-                                     <+> "=" <+> pretty p
-            Mutual _ ds     -> namedBlock "mutual" ds
-            InterleavedMutual _ ds  -> namedBlock "interleaved mutual" ds
-            LoneConstructor _ ds -> namedBlock "constructor" ds
-            Abstract _ ds   -> namedBlock "abstract" ds
-            Private _ _ ds  -> namedBlock "private" ds
-            InstanceB _ ds  -> namedBlock "instance" ds
-            Macro _ ds      -> namedBlock "macro" ds
-            Postulate _ ds  -> namedBlock "postulate" ds
-            Primitive _ ds  -> namedBlock "primitive" ds
-            Generalize _ ds -> namedBlock "variable" ds
-            Module _ x tel ds ->
-                hsep [ "module"
-                     , pretty x
-                     , fcat (map pretty tel)
-                     , "where"
-                     ] $$ nest 2 (vcat $ map pretty ds)
-            ModuleMacro _ x (SectionApp _ [] e) DoOpen i | isNoName x ->
-                sep [ pretty DoOpen
-                    , nest 2 $ pretty e
-                    , nest 4 $ pretty i
-                    ]
-            ModuleMacro _ x (SectionApp _ tel e) open i ->
-                sep [ pretty open <+> "module" <+> pretty x <+> fcat (map pretty tel)
-                    , nest 2 $ "=" <+> pretty e <+> pretty i
-                    ]
-            ModuleMacro _ x (RecordModuleInstance _ rec) open i ->
-                sep [ pretty open <+> "module" <+> pretty x
-                    , nest 2 $ "=" <+> pretty rec <+> "{{...}}"
-                    ]
-            Open _ x i  -> hsep [ "open", pretty x, pretty i ]
-            Import _ x rn open i   ->
-                hsep [ pretty open, "import", pretty x, as rn, pretty i ]
-                where
-                    as Nothing  = empty
-                    as (Just x) = "as" <+> pretty (asName x)
-            UnquoteDecl _ xs t ->
-              sep [ "unquoteDecl" <+> fsep (map pretty xs) <+> "=", nest 2 $ pretty t ]
-            UnquoteDef _ xs t ->
-              sep [ "unquoteDef" <+> fsep (map pretty xs) <+> "=", nest 2 $ pretty t ]
-            Pragma pr   -> sep [ "{-#" <+> pretty pr, "#-}" ]
-        where
-            namedBlock s ds =
-                sep [ text s
-                    , nest 2 $ vcat $ map pretty ds
-                    ]
+          , nest 2 $ hsep
+                  [ ":"
+                  , pretty e
+                  ]
+          ]
+    Data _ x tel e cs ->
+      sep [ hsep  [ "data"
+                  , pretty x
+                  , fcat (map pretty tel)
+                  ]
+          , nest 2 $ hsep
+                  [ ":"
+                  , pretty e
+                  , "where"
+                  ]
+          ] $$ nest 2 (vcat $ map pretty cs)
+    DataDef _ x tel cs ->
+      sep [ hsep  [ "data"
+                  , pretty x
+                  , fcat (map pretty tel)
+                  ]
+          , nest 2 $ "where"
+          ] $$ nest 2 (vcat $ map pretty cs)
+    RecordSig _ x tel e ->
+      sep [ hsep  [ "record"
+                  , pretty x
+                  , fcat (map pretty tel)
+                  ]
+          , nest 2 $ hsep
+                  [ ":"
+                  , pretty e
+                  ]
+          ]
+    Record _ x dir tel e cs ->
+      pRecord x dir tel (Just e) cs
+    RecordDef _ x dir tel cs ->
+      pRecord x dir tel Nothing cs
+    RecordDirective r -> pRecordDirective r
+    Infix f xs  ->
+      pretty f <+> fsep (punctuate comma $ fmap pretty xs)
+    Syntax n xs -> "syntax" <+> pretty n <+> "..."
+    PatternSyn _ n as p -> "pattern" <+> pretty n <+> fsep (map pretty as)
+                             <+> "=" <+> pretty p
+    Mutual _ ds     -> namedBlock "mutual" ds
+    InterleavedMutual _ ds  -> namedBlock "interleaved mutual" ds
+    LoneConstructor _ ds -> namedBlock "constructor" ds
+    Abstract _ ds   -> namedBlock "abstract" ds
+    Private _ _ ds  -> namedBlock "private" ds
+    InstanceB _ ds  -> namedBlock "instance" ds
+    Macro _ ds      -> namedBlock "macro" ds
+    Postulate _ ds  -> namedBlock "postulate" ds
+    Primitive _ ds  -> namedBlock "primitive" ds
+    Generalize _ ds -> namedBlock "variable" ds
+    Module _ x tel ds ->
+      hsep [ "module"
+           , pretty x
+           , fcat (map pretty tel)
+           , "where"
+           ] $$ nest 2 (vcat $ map pretty ds)
+    ModuleMacro _ x (SectionApp _ [] e) DoOpen i | isNoName x ->
+      sep [ pretty DoOpen
+          , nest 2 $ pretty e
+          , nest 4 $ pretty i
+          ]
+    ModuleMacro _ x (SectionApp _ tel e) open i ->
+      sep [ pretty open <+> "module" <+> pretty x <+> fcat (map pretty tel)
+          , nest 2 $ "=" <+> pretty e <+> pretty i
+          ]
+    ModuleMacro _ x (RecordModuleInstance _ rec) open i ->
+      sep [ pretty open <+> "module" <+> pretty x
+          , nest 2 $ "=" <+> pretty rec <+> "{{...}}"
+          ]
+    Open _ x i  -> hsep [ "open", pretty x, pretty i ]
+    Import _ x rn open i   ->
+      hsep [ pretty open, "import", pretty x, as rn, pretty i ]
+      where
+        as Nothing  = empty
+        as (Just x) = "as" <+> pretty (asName x)
+    UnquoteDecl _ xs t ->
+      sep [ "unquoteDecl" <+> fsep (map pretty xs) <+> "=", nest 2 $ pretty t ]
+    UnquoteDef _ xs t ->
+      sep [ "unquoteDef" <+> fsep (map pretty xs) <+> "=", nest 2 $ pretty t ]
+    UnquoteData _ x xs t ->
+      sep [ "unquoteData" <+> pretty x <+> fsep (map pretty xs) <+> "=", nest 2 $ pretty t ]
+    Pragma pr   -> sep [ "{-#" <+> pretty pr, "#-}" ]
+    where
+      namedBlock s ds =
+          sep [ text s
+              , nest 2 $ vcat $ map pretty ds
+              ]
 
 pHasEta0 :: HasEta0 -> Doc
 pHasEta0 = \case
diff --git a/src/full/Agda/Syntax/Parser/Parser.y b/src/full/Agda/Syntax/Parser/Parser.y
index 275c28468..369d36e34 100644
--- a/src/full/Agda/Syntax/Parser/Parser.y
+++ b/src/full/Agda/Syntax/Parser/Parser.y
@@ -1307,6 +1307,9 @@ Primitive : 'primitive' ArgTypeSignaturesOrEmpty  {
 UnquoteDecl :: { Declaration }
 UnquoteDecl
   : 'unquoteDecl' '=' Expr { UnquoteDecl (fuseRange $1 $3) [] $3 }
+  | 'unquoteDecl' 'data' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $5)) (List1.toList $3) [] $5 }
+  | 'unquoteDecl' 'constructor' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $5)) [] (List1.toList $3) $5 }
+  | 'unquoteDecl' 'data' SpaceIds 'constructor' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $4, $7)) (List1.toList $3) (List1.toList $5) $7 }
   | 'unquoteDecl' SpaceIds '=' Expr { UnquoteDecl (fuseRange $1 $4) (List1.toList $2) $4 }
   | 'unquoteDef'  SpaceIds '=' Expr { UnquoteDef (fuseRange $1 $4) (List1.toList $2) $4 }
 
diff --git a/src/full/Agda/Syntax/Translation/AbstractToConcrete.hs b/src/full/Agda/Syntax/Translation/AbstractToConcrete.hs
index c6d47e098..b06f4cd49 100644
--- a/src/full/Agda/Syntax/Translation/AbstractToConcrete.hs
+++ b/src/full/Agda/Syntax/Translation/AbstractToConcrete.hs
@@ -1266,6 +1266,8 @@ instance ToConcrete A.Declaration where
     xs <- mapM (unqual <=< toConcrete) xs
     (:[]) . C.UnquoteDef (getRange i) xs <$> toConcrete e
 
+  toConcrete (A.UnquoteData i xs uc j cs e) = __IMPOSSIBLE__
+
 
 data RangeAndPragma = RangeAndPragma Range A.Pragma
 
diff --git a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
index c2e7ea495..b37d32aa8 100644
--- a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
+++ b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
@@ -225,6 +225,7 @@ recordConstructorType decls =
         C.NiceGeneralize{}    -> failure
         C.NiceUnquoteDecl{}   -> failure
         C.NiceUnquoteDef{}    -> failure
+        C.NiceUnquoteData{}   -> failure
 
 checkModuleApplication
   :: C.ModuleApplication
@@ -1719,7 +1720,9 @@ instance ToAbstract NiceDeclaration where
 
   -- Definitions (possibly mutual)
     NiceMutual r tc cc pc ds -> do
+      reportSLn "scope.mutual" 20 ("starting checking mutual definitions: " ++ prettyShow ds)
       ds' <- toAbstract ds
+      reportSLn "scope.mutual" 20 ("finishing checking mutual definitions")
       -- We only termination check blocks that do not have a measure.
       return [ A.Mutual (MutualInfo tc cc pc r) ds' ]
 
@@ -2039,6 +2042,36 @@ instance ToAbstract NiceDeclaration where
       zipWithM_ (rebindName p OtherDefName) xs ys
       return [ A.UnquoteDef [ mkDefInfo x fx PublicAccess a r | (fx, x) <- zip fxs xs ] ys e ]
 
+    NiceUnquoteData r p a pc uc xs cs e -> do
+      x <- maybe (typeError $ GenericError $ "Cannot unquote multiple data names at once")
+                 (return . List1.head)
+                 (List1.nonEmpty xs)
+      fx <- getConcreteFixity x
+      x' <- freshAbstractQName fx x
+      bindName p QuotableName x x'
+
+      -- Create the module for the qualified constructors
+      checkForModuleClash x
+      let m = qnameToMName x'
+      createModule (Just IsDataModule) m
+      bindModule p x m  -- make it a proper module
+
+      cs' <- withCurrentModule m $ mapM (bindUnquoteConstructorName m p) cs
+
+      e <- withCurrentModule m $ toAbstract e
+
+      rebindName p DataName x x'
+      withCurrentModule m $ zipWithM_ (rebindName p ConName) cs cs'
+
+      fcs <- mapM getConcreteFixity cs
+      let mi = MutualInfo TerminationCheck YesCoverageCheck pc r
+      return
+        [ A.Mutual
+          mi [A.UnquoteData
+            [ mkDefInfo x fx p a r ] [x'] uc
+            [ mkDefInfo c fc p a r | (fc, c) <- zip fcs cs] cs' e ]
+        ]
+
     NicePatternSyn r a n as p -> do
       reportSLn "scope.pat" 10 $ "found nice pattern syn: " ++ prettyShow n
       (as, p) <- withLocalVars $ do
@@ -2237,6 +2270,25 @@ bindRecordConstructorName x kind a p = do
            AbstractDef -> PrivateAccess Inserted
            _           -> p
 
+bindUnquoteConstructorName :: ModuleName -> Access -> C.Name -> TCM A.QName
+bindUnquoteConstructorName m p c = do
+
+  r <- resolveName (C.QName c)
+  fc <- getConcreteFixity c
+  c' <- withCurrentModule m $ freshAbstractQName fc c
+  let aname qn = AbsName qn QuotableName Defined NoMetadata
+      addName = modifyCurrentScope $ addNameToScope (localNameSpace p) c $ aname c'
+      success = addName >> (withCurrentModule m $ addName)
+  case r of
+    _ | isNoName c       -> success
+    UnknownName          -> success
+    ConstructorName i ds -> if all (isJust . isConName . anameKind) ds
+      then success
+      else typeError $ ClashingDefinition (C.QName c) (anameName $ List1.head ds) Nothing
+    _ -> typeError $ GenericError $
+       "The name " ++ prettyShow c ++ " already has non-constructor definitions"
+  return c'
+
 instance ToAbstract DataConstrDecl where
   type AbsOfCon DataConstrDecl = A.Declaration
 
diff --git a/src/full/Agda/Termination/TermCheck.hs b/src/full/Agda/Termination/TermCheck.hs
index d24734356..39fa79d67 100644
--- a/src/full/Agda/Termination/TermCheck.hs
+++ b/src/full/Agda/Termination/TermCheck.hs
@@ -125,6 +125,7 @@ termDecl' = \case
     A.DataDef{}     -> __IMPOSSIBLE__
     A.UnquoteDecl{} -> __IMPOSSIBLE__
     A.UnquoteDef{}  -> __IMPOSSIBLE__
+    A.UnquoteData{} -> __IMPOSSIBLE__
   where
     termDecls ds = concat <$> mapM termDecl' ds
 
diff --git a/src/full/Agda/TypeChecking/Rules/Decl.hs b/src/full/Agda/TypeChecking/Rules/Decl.hs
index 5cd36839c..1202df6b2 100644
--- a/src/full/Agda/TypeChecking/Rules/Decl.hs
+++ b/src/full/Agda/TypeChecking/Rules/Decl.hs
@@ -193,6 +193,9 @@ checkDecl d = setCurrentRange d $ do
       -- TODO: Benchmarking for unquote.
       A.UnquoteDecl mi is xs e -> checkMaybeAbstractly is $ checkUnquoteDecl mi is xs e
       A.UnquoteDef is xs e     -> impossible $ checkMaybeAbstractly is $ checkUnquoteDef is xs e
+      A.UnquoteData is xs uc js cs e -> checkMaybeAbstractly (is ++ js) $ do
+        reportSDoc "tc.unquote.data" 20 $ "Checking unquoteDecl data" <+> sep (map prettyTCM xs)
+        Nothing <$ unquoteTop (xs ++ cs) e
 
     whenNothingM (asksTC envMutualBlock) $ do
 
@@ -402,6 +405,7 @@ highlight_ hlmod d = do
     A.Generalize{}           -> highlight d
     A.UnquoteDecl{}          -> highlight d
     A.UnquoteDef{}           -> highlight d
+    A.UnquoteData{}           -> highlight d
     A.Section i x tel ds     -> do
       highlight (A.Section i x tel [])
       when (hlmod == DoHighlightModuleContents) $ mapM_ (highlight_ hlmod) (deepUnscopeDecls ds)
@@ -1031,6 +1035,7 @@ instance ShowHead A.Declaration where
       A.UnquoteDecl  {} -> "UnquoteDecl"
       A.ScopedDecl   {} -> "ScopedDecl"
       A.UnquoteDef   {} -> "UnquoteDef"
+      A.UnquoteData   {} -> "UnquoteDecl data"
 
 debugPrintDecl :: A.Declaration -> TCM ()
 debugPrintDecl d = do
-- 
2.31.0

From c274216854e6ad358e2011ed2a2e5d2b32cf0083 Mon Sep 17 00:00:00 2001
From: Viktor Lin <hi@viktorl.in>
Date: Fri, 16 Jul 2021 14:00:19 +0800
Subject: [PATCH] [ reflection ] Add primitives tcDeclareData and tcDefineData

The type of a constructor given to tcDefineData excludes data type parameters.
---
 doc/user-manual/language/reflection.lagda.rst |  13 ++
 .../lib/prim/Agda/Builtin/Reflection.agda     |   6 +
 src/full/Agda/Compiler/MAlonzo/Compiler.hs    |   2 +
 src/full/Agda/Syntax/Builtin.hs               |   4 +-
 src/full/Agda/Syntax/Concrete/Definitions.hs  |   2 +-
 src/full/Agda/TypeChecking/Monad/Builtin.hs   |   4 +-
 src/full/Agda/TypeChecking/Rules/Builtin.hs   |   2 +
 src/full/Agda/TypeChecking/Rules/Decl.hs      |  10 +-
 src/full/Agda/TypeChecking/Rules/Decl.hs-boot |   2 +
 src/full/Agda/TypeChecking/Unquote.hs         | 112 ++++++++++++++++--
 10 files changed, 139 insertions(+), 18 deletions(-)

diff --git a/doc/user-manual/language/reflection.lagda.rst b/doc/user-manual/language/reflection.lagda.rst
index e6389f515..329c2e59e 100644
--- a/doc/user-manual/language/reflection.lagda.rst
+++ b/doc/user-manual/language/reflection.lagda.rst
@@ -450,6 +450,17 @@ following primitive operations::
     -- option.
     declarePostulate : Arg Name → Type → TC ⊤
 
+    -- Declare a new datatype. The second argument indicates how many preceding
+    -- types of the third argument are parameters. The datatype must be defined
+    -- later using 'defineData'.
+    declareData      : Name → Nat → Type → TC ⊤
+
+    -- Define a declared datatype with constructor definitions. The datatype
+    -- may have been declared using 'declareData' or with the keyword
+    -- 'data ... where ... '. The second argument is a list of pairs, each
+    -- containing a name of a constructor and its type.
+    defineData       : Name → List (Σ Name (λ _ → Type)) → TC ⊤
+
     -- Define a declared function. The function may have been declared using
     -- 'declareDef' or with an explicit type signature in the program.
     defineFun : Name → List Clause → TC ⊤
@@ -518,6 +529,8 @@ following primitive operations::
   {-# BUILTIN AGDATCMFRESHNAME                  freshName                  #-}
   {-# BUILTIN AGDATCMDECLAREDEF                 declareDef                 #-}
   {-# BUILTIN AGDATCMDECLAREPOSTULATE           declarePostulate           #-}
+  {-# BUILTIN AGDATCMDECLAREDATA                declareData                #-}
+  {-# BUILTIN AGDATCMDEFINEDATA                 defineData                 #-}
   {-# BUILTIN AGDATCMDEFINEFUN                  defineFun                  #-}
   {-# BUILTIN AGDATCMGETTYPE                    getType                    #-}
   {-# BUILTIN AGDATCMGETDEFINITION              getDefinition              #-}
diff --git a/src/data/lib/prim/Agda/Builtin/Reflection.agda b/src/data/lib/prim/Agda/Builtin/Reflection.agda
index 597772348..2b26ab05d 100644
--- a/src/data/lib/prim/Agda/Builtin/Reflection.agda
+++ b/src/data/lib/prim/Agda/Builtin/Reflection.agda
@@ -285,6 +285,8 @@ postulate
   freshName        : String → TC Name
   declareDef       : Arg Name → Type → TC ⊤
   declarePostulate : Arg Name → Type → TC ⊤
+  declareData      : Name → Nat → Type → TC ⊤
+  defineData       : Name → List (Σ Name (λ _ → Type)) → TC ⊤
   defineFun        : Name → List Clause → TC ⊤
   getType          : Name → TC Type
   getDefinition    : Name → TC Definition
@@ -343,6 +345,8 @@ postulate
 {-# BUILTIN AGDATCMFRESHNAME                  freshName                  #-}
 {-# BUILTIN AGDATCMDECLAREDEF                 declareDef                 #-}
 {-# BUILTIN AGDATCMDECLAREPOSTULATE           declarePostulate           #-}
+{-# BUILTIN AGDATCMDECLAREDATA                declareData                #-}
+{-# BUILTIN AGDATCMDEFINEDATA                 defineData                 #-}
 {-# BUILTIN AGDATCMDEFINEFUN                  defineFun                  #-}
 {-# BUILTIN AGDATCMGETTYPE                    getType                    #-}
 {-# BUILTIN AGDATCMGETDEFINITION              getDefinition              #-}
@@ -381,6 +385,8 @@ postulate
 {-# COMPILE JS freshName         = _ =>                undefined #-}
 {-# COMPILE JS declareDef        = _ => _ =>           undefined #-}
 {-# COMPILE JS declarePostulate  = _ => _ =>           undefined #-}
+{-# COMPILE JS declareData       = _ => _ => _ =>      undefined #-}
+{-# COMPILE JS defineData        = _ => _ =>           undefined #-}
 {-# COMPILE JS defineFun         = _ => _ =>           undefined #-}
 {-# COMPILE JS getType           = _ =>                undefined #-}
 {-# COMPILE JS getDefinition     = _ =>                undefined #-}
diff --git a/src/full/Agda/Compiler/MAlonzo/Compiler.hs b/src/full/Agda/Compiler/MAlonzo/Compiler.hs
index 4cdb1b496..fd3eadce2 100644
--- a/src/full/Agda/Compiler/MAlonzo/Compiler.hs
+++ b/src/full/Agda/Compiler/MAlonzo/Compiler.hs
@@ -267,6 +267,8 @@ ghcPreCompile flags = do
       , builtinAgdaTCMFreshName
       , builtinAgdaTCMDeclareDef
       , builtinAgdaTCMDeclarePostulate
+      , builtinAgdaTCMDeclareData
+      , builtinAgdaTCMDefineData
       , builtinAgdaTCMDefineFun
       , builtinAgdaTCMGetType
       , builtinAgdaTCMGetDefinition
diff --git a/src/full/Agda/Syntax/Builtin.hs b/src/full/Agda/Syntax/Builtin.hs
index 7c6a22be4..1233919af 100644
--- a/src/full/Agda/Syntax/Builtin.hs
+++ b/src/full/Agda/Syntax/Builtin.hs
@@ -65,7 +65,7 @@ builtinNat, builtinSuc, builtinZero, builtinNatPlus, builtinNatMinus,
   builtinAgdaTCMCheckType, builtinAgdaTCMNormalise, builtinAgdaTCMReduce,
   builtinAgdaTCMCatchError,
   builtinAgdaTCMGetContext, builtinAgdaTCMExtendContext, builtinAgdaTCMInContext,
-  builtinAgdaTCMFreshName, builtinAgdaTCMDeclareDef, builtinAgdaTCMDeclarePostulate, builtinAgdaTCMDefineFun,
+  builtinAgdaTCMFreshName, builtinAgdaTCMDeclareDef, builtinAgdaTCMDeclarePostulate, builtinAgdaTCMDeclareData, builtinAgdaTCMDefineData, builtinAgdaTCMDefineFun,
   builtinAgdaTCMGetType, builtinAgdaTCMGetDefinition,
   builtinAgdaTCMQuoteTerm, builtinAgdaTCMUnquoteTerm, builtinAgdaTCMQuoteOmegaTerm,
   builtinAgdaTCMBlockOnMeta, builtinAgdaTCMCommit, builtinAgdaTCMIsMacro,
@@ -263,6 +263,8 @@ builtinAgdaTCMInContext                  = "AGDATCMINCONTEXT"
 builtinAgdaTCMFreshName                  = "AGDATCMFRESHNAME"
 builtinAgdaTCMDeclareDef                 = "AGDATCMDECLAREDEF"
 builtinAgdaTCMDeclarePostulate           = "AGDATCMDECLAREPOSTULATE"
+builtinAgdaTCMDeclareData                = "AGDATCMDECLAREDATA"
+builtinAgdaTCMDefineData                 = "AGDATCMDEFINEDATA"
 builtinAgdaTCMDefineFun                  = "AGDATCMDEFINEFUN"
 builtinAgdaTCMGetType                    = "AGDATCMGETTYPE"
 builtinAgdaTCMGetDefinition              = "AGDATCMGETDEFINITION"
diff --git a/src/full/Agda/Syntax/Concrete/Definitions.hs b/src/full/Agda/Syntax/Concrete/Definitions.hs
index 0717c5248..e01bc6e6a 100644
--- a/src/full/Agda/Syntax/Concrete/Definitions.hs
+++ b/src/full/Agda/Syntax/Concrete/Definitions.hs
@@ -1171,7 +1171,7 @@ niceDeclarations fixs ds = do
         covCheck NicePatternSyn{}    = YesCoverageCheck
         covCheck NiceGeneralize{}    = YesCoverageCheck
         covCheck NiceLoneConstructor{} = YesCoverageCheck
-        covCheck NiceUnquoteData{}   = YesCoverageCheck 
+        covCheck NiceUnquoteData{}   = YesCoverageCheck
 
         -- ASR (26 December 2015): Do not positivity check a mutual
         -- block if any of its inner declarations comes with a
diff --git a/src/full/Agda/TypeChecking/Monad/Builtin.hs b/src/full/Agda/TypeChecking/Monad/Builtin.hs
index ba389aca5..8dbdcc676 100644
--- a/src/full/Agda/TypeChecking/Monad/Builtin.hs
+++ b/src/full/Agda/TypeChecking/Monad/Builtin.hs
@@ -214,7 +214,7 @@ primInteger, primIntegerPos, primIntegerNegSuc,
     primAgdaTCMTypeError, primAgdaTCMInferType, primAgdaTCMCheckType,
     primAgdaTCMNormalise, primAgdaTCMReduce,
     primAgdaTCMCatchError, primAgdaTCMGetContext, primAgdaTCMExtendContext, primAgdaTCMInContext,
-    primAgdaTCMFreshName, primAgdaTCMDeclareDef, primAgdaTCMDeclarePostulate, primAgdaTCMDefineFun,
+    primAgdaTCMFreshName, primAgdaTCMDeclareDef, primAgdaTCMDeclarePostulate, primAgdaTCMDeclareData, primAgdaTCMDefineData, primAgdaTCMDefineFun,
     primAgdaTCMGetType, primAgdaTCMGetDefinition,
     primAgdaTCMQuoteTerm, primAgdaTCMUnquoteTerm, primAgdaTCMQuoteOmegaTerm,
     primAgdaTCMBlockOnMeta, primAgdaTCMCommit, primAgdaTCMIsMacro,
@@ -409,6 +409,8 @@ primAgdaTCMInContext                  = getBuiltin builtinAgdaTCMInContext
 primAgdaTCMFreshName                  = getBuiltin builtinAgdaTCMFreshName
 primAgdaTCMDeclareDef                 = getBuiltin builtinAgdaTCMDeclareDef
 primAgdaTCMDeclarePostulate           = getBuiltin builtinAgdaTCMDeclarePostulate
+primAgdaTCMDeclareData                = getBuiltin builtinAgdaTCMDeclareData
+primAgdaTCMDefineData                 = getBuiltin builtinAgdaTCMDefineData
 primAgdaTCMDefineFun                  = getBuiltin builtinAgdaTCMDefineFun
 primAgdaTCMGetType                    = getBuiltin builtinAgdaTCMGetType
 primAgdaTCMGetDefinition              = getBuiltin builtinAgdaTCMGetDefinition
diff --git a/src/full/Agda/TypeChecking/Rules/Builtin.hs b/src/full/Agda/TypeChecking/Rules/Builtin.hs
index 0220b5251..1e4ba40ef 100644
--- a/src/full/Agda/TypeChecking/Rules/Builtin.hs
+++ b/src/full/Agda/TypeChecking/Rules/Builtin.hs
@@ -371,6 +371,8 @@ coreBuiltins =
   , builtinAgdaTCMFreshName                  |-> builtinPostulate (tstring --> tTCM_ primQName)
   , builtinAgdaTCMDeclareDef                 |-> builtinPostulate (targ tqname --> ttype --> tTCM_ primUnit)
   , builtinAgdaTCMDeclarePostulate           |-> builtinPostulate (targ tqname --> ttype --> tTCM_ primUnit)
+  , builtinAgdaTCMDeclareData                |-> builtinPostulate (tqname --> tnat --> ttype --> tTCM_ primUnit)
+  , builtinAgdaTCMDefineData                 |-> builtinPostulate (tqname --> tlist (tpair primLevelZero primLevelZero tqname ttype) --> tTCM_ primUnit)
   , builtinAgdaTCMDefineFun                  |-> builtinPostulate (tqname --> tlist tclause --> tTCM_ primUnit)
   , builtinAgdaTCMGetType                    |-> builtinPostulate (tqname --> tTCM_ primAgdaTerm)
   , builtinAgdaTCMGetDefinition              |-> builtinPostulate (tqname --> tTCM_ primAgdaDefinition)
diff --git a/src/full/Agda/TypeChecking/Rules/Decl.hs b/src/full/Agda/TypeChecking/Rules/Decl.hs
index 1202df6b2..2e78d7634 100644
--- a/src/full/Agda/TypeChecking/Rules/Decl.hs
+++ b/src/full/Agda/TypeChecking/Rules/Decl.hs
@@ -223,10 +223,6 @@ checkDecl d = setCurrentRange d $ do
 
     where
 
-    -- check record or data type signature
-    checkSig kind i x gtel t = checkTypeSignature' (Just gtel) $
-      A.Axiom kind i defaultArgInfo Nothing x t
-
     -- Switch maybe to abstract mode, benchmark, and debug print bracket.
     check :: forall m i a
           . ( MonadTCEnv m, MonadPretty m, MonadDebug m
@@ -787,6 +783,12 @@ checkMutual i ds = inMutualBlock $ \ blockId -> defaultOpenLevelsToZero $ do
 
   (blockId, ) . mutualNames <$> lookupMutualBlock blockId
 
+    -- check record or data type signature
+checkSig :: KindOfName -> A.DefInfo -> QName -> A.GeneralizeTelescope -> A.Expr -> TCM ()
+checkSig kind i x gtel t = checkTypeSignature' (Just gtel) $
+  A.Axiom kind i defaultArgInfo Nothing x t
+
+
 -- | Type check the type signature of an inductive or recursive definition.
 checkTypeSignature :: A.TypeSignature -> TCM ()
 checkTypeSignature = checkTypeSignature' Nothing
diff --git a/src/full/Agda/TypeChecking/Rules/Decl.hs-boot b/src/full/Agda/TypeChecking/Rules/Decl.hs-boot
index 959b818d7..79f9a69ae 100644
--- a/src/full/Agda/TypeChecking/Rules/Decl.hs-boot
+++ b/src/full/Agda/TypeChecking/Rules/Decl.hs-boot
@@ -3,8 +3,10 @@ module Agda.TypeChecking.Rules.Decl where
 
 import Agda.Syntax.Info (ModuleInfo)
 import Agda.Syntax.Abstract
+import Agda.Syntax.Scope.Base
 import Agda.TypeChecking.Monad.Base (TCM)
 
 checkDecls :: [Declaration] -> TCM ()
 checkDecl  :: Declaration -> TCM ()
+checkSig   :: KindOfName -> DefInfo -> QName -> GeneralizeTelescope -> Expr -> TCM ()
 checkSectionApplication :: ModuleInfo -> ModuleName -> ModuleApplication -> ScopeCopyInfo -> TCM ()
diff --git a/src/full/Agda/TypeChecking/Unquote.hs b/src/full/Agda/TypeChecking/Unquote.hs
index 11e541fbf..12a794190 100644
--- a/src/full/Agda/TypeChecking/Unquote.hs
+++ b/src/full/Agda/TypeChecking/Unquote.hs
@@ -2,7 +2,7 @@
 module Agda.TypeChecking.Unquote where
 
 import Control.Arrow          ( first, second, (&&&) )
-import Control.Monad          ( (<=<) )
+import Control.Monad          ( (<=<), liftM2 )
 import Control.Monad.Except   ( MonadError(..), ExceptT(..), runExceptT )
 import Control.Monad.IO.Class ( MonadIO(..) )
 import Control.Monad.Reader   ( ReaderT(..), runReaderT )
@@ -28,10 +28,13 @@ import Agda.Syntax.Common hiding ( Nat )
 import Agda.Syntax.Internal as I
 import qualified Agda.Syntax.Reflected as R
 import qualified Agda.Syntax.Abstract as A
+import Agda.Syntax.Abstract.Views
+import Agda.Syntax.Translation.InternalToAbstract
 import Agda.Syntax.Literal
 import Agda.Syntax.Position
 import Agda.Syntax.Info
 import Agda.Syntax.Translation.ReflectedToAbstract
+import Agda.Syntax.Scope.Base (KindOfName(ConName, DataName))
 
 import Agda.Interaction.Library ( ExeName )
 import Agda.Interaction.Options ( optTrustedExecutables, optAllowExec )
@@ -54,6 +57,8 @@ import Agda.TypeChecking.InstanceArguments ( getInstanceCandidates )
 
 import {-# SOURCE #-} Agda.TypeChecking.Rules.Term
 import {-# SOURCE #-} Agda.TypeChecking.Rules.Def
+import {-# SOURCE #-} Agda.TypeChecking.Rules.Decl
+import Agda.TypeChecking.Rules.Data
 
 import Agda.Utils.Either
 import Agda.Utils.Lens
@@ -575,20 +580,22 @@ evalTCM v = do
              , (f `isDef` primAgdaTCMCheckType,  tcFun2 tcCheckType  u v)
              , (f `isDef` primAgdaTCMDeclareDef, uqFun2 tcDeclareDef u v)
              , (f `isDef` primAgdaTCMDeclarePostulate, uqFun2 tcDeclarePostulate u v)
+             , (f `isDef` primAgdaTCMDefineData, uqFun2 tcDefineData u v)
              , (f `isDef` primAgdaTCMDefineFun,  uqFun2 tcDefineFun  u v)
              , (f `isDef` primAgdaTCMQuoteOmegaTerm, tcQuoteTerm (unElim v))
              ]
              failEval
     I.Def f [l, a, u] ->
-      choice [ (f `isDef` primAgdaTCMReturn,             return (unElim u))
-             , (f `isDef` primAgdaTCMTypeError,          tcFun1 tcTypeError   u)
-             , (f `isDef` primAgdaTCMQuoteTerm,          tcQuoteTerm (unElim u))
-             , (f `isDef` primAgdaTCMUnquoteTerm,        tcFun1 (tcUnquoteTerm (mkT (unElim l) (unElim a))) u)
-             , (f `isDef` primAgdaTCMBlockOnMeta,        uqFun1 tcBlockOnMeta u)
-             , (f `isDef` primAgdaTCMDebugPrint,         tcFun3 tcDebugPrint l a u)
-             , (f `isDef` primAgdaTCMNoConstraints,      tcNoConstraints (unElim u))
-             , (f `isDef` primAgdaTCMWithReconsParams,   tcWithReconsParams (unElim u))
-             , (f `isDef` primAgdaTCMRunSpeculative,     tcRunSpeculative (unElim u))
+      choice [ (f `isDef` primAgdaTCMReturn,      return (unElim u))
+             , (f `isDef` primAgdaTCMTypeError,   tcFun1 tcTypeError   u)
+             , (f `isDef` primAgdaTCMQuoteTerm,   tcQuoteTerm (unElim u))
+             , (f `isDef` primAgdaTCMUnquoteTerm, tcFun1 (tcUnquoteTerm (mkT (unElim l) (unElim a))) u)
+             , (f `isDef` primAgdaTCMBlockOnMeta, uqFun1 tcBlockOnMeta u)
+             , (f `isDef` primAgdaTCMDebugPrint,  tcFun3 tcDebugPrint l a u)
+             , (f `isDef` primAgdaTCMNoConstraints, tcNoConstraints (unElim u))
+             , (f `isDef` primAgdaTCMWithReconsParams, tcWithReconsParams (unElim u))
+             , (f `isDef` primAgdaTCMDeclareData, uqFun3 tcDeclareData l a u)
+             , (f `isDef` primAgdaTCMRunSpeculative, tcRunSpeculative (unElim u))
              , (f `isDef` primAgdaTCMExec, tcFun3 tcExec l a u)
              ]
              failEval
@@ -930,6 +937,86 @@ evalTCM v = do
         when (isInstance i) $ addTypedInstance x a
         primUnitUnit
 
+    -- A datatype is expected to be declared with a function type.
+    -- The second argument indicates how many preceding types are parameters.
+    tcDeclareData :: QName -> Integer -> R.Type -> UnquoteM Term
+    tcDeclareData x npars t = inOriginalContext $ do
+      setDirty
+      tell [x]
+      liftTCM $ do
+        reportSDoc "tc.unquote.decl" 10 $ sep
+          [ "declare Data" <+> prettyTCM x <+> ":"
+          , nest 2 $ prettyR t
+          ]
+        alreadyDefined <- isRight <$> getConstInfo' x
+        when alreadyDefined $ genericError $ "Multiple declarations of " ++ prettyShow x
+        e <- toAbstract_ t
+        -- The type to be checked with @checkSig@ is without parameters.
+        let (tel, e') = splitPars (fromInteger npars) e
+        ac <- asksTC (^. lensIsAbstract)
+        let defIn = mkDefInfo (nameConcrete $ qnameName x) noFixity' PublicAccess ac noRange
+        checkSig DataName defIn x (A.GeneralizeTel Map.empty tel) e'
+        primUnitUnit
+
+    tcDefineData :: QName -> [(QName, R.Type)] -> UnquoteM Term
+    tcDefineData x cs = inOriginalContext $ (setDirty >>) $ liftTCM $ do
+      caseEitherM (getConstInfo' x)
+        (const $ genericError $ "Missing declaration for " ++ prettyShow x) $ \def -> do
+        npars <- case theDef def of
+                   DataOrRecSig n -> return n
+                   _              -> genericError $ prettyShow x ++
+                     " is not declared as a datatype or record, or it already has a definition."
+
+        -- For some reasons, reifying parameters and adding them to the context via
+        -- `addContext` before `toAbstract_` is different from substituting the type after
+        -- `toAbstract_, so some dummy parameters are added and removed later.
+        es <- mapM (toAbstract_ . addDummy npars . snd) cs
+        reportSDoc "tc.unquote.def" 10 $ vcat $
+          [ "declaring constructors of" <+> prettyTCM x <+> ":" ] ++ map prettyA es
+
+        -- Translate parameters from internal definitions back to abstract syntax.
+        t   <- instantiateFull . defType =<< instantiateDef def
+        tel <- reify =<< theTel <$> telViewUpTo npars t
+
+        es' <- case mapM (uncurry (substNames' tel) . splitPars npars) es of
+                 Nothing -> genericError $ "Number of parameters doesn't match!"
+                 Just es -> return es
+
+        ac <- asksTC (^. lensIsAbstract)
+        let i = mkDefInfo (nameConcrete $ qnameName x) noFixity' PublicAccess ac noRange
+            conNames = map fst cs
+            toAxiom c e = A.Axiom ConName i defaultArgInfo Nothing c e
+            as = zipWith toAxiom conNames es'
+            lams = map (\case {A.TBind _ tac (b :| []) _ -> A.DomainFree tac b
+                              ;_ -> __IMPOSSIBLE__ }) tel
+        reportSDoc "tc.unquote.def" 10 $ vcat $
+          [ "checking datatype: " <+> prettyTCM x <+> " with constructors:"
+          , nest 2 (vcat (map prettyTCM conNames))
+          ]
+        checkDataDef i x YesUniverseCheck (A.DataDefParams Set.empty lams) as
+        primUnitUnit
+      where
+        addDummy :: Int -> R.Type -> R.Type
+        addDummy 0 t = t
+        addDummy n t = R.Pi (defaultDom (R.Sort $ R.LitS 0)) (R.Abs "dummy" $ addDummy (n - 1) t)
+
+        substNames' :: [A.TypedBinding] -> [A.TypedBinding] -> A.Expr -> Maybe A.Expr
+        substNames' (a : as) (b : bs) e = do
+          let (A.TBind _ _ (na :| _) expra) = a
+              (A.TBind _ _ (nb :| _) exprb) = b
+              getName n = A.unBind . A.binderName $ namedArg n
+          e' <- substNames' as bs e
+          return $ mapExpr (substName (getName na) (getName nb)) e'
+          where
+            -- Substitute @Var x@ for @Var y@ in an @Expr@.
+            substName :: Name -> Name -> (A.Expr -> A.Expr)
+            substName x y e@(A.Var n)
+                    | y == n    = A.Var x
+                    | otherwise = e
+            substName _ _ e = e
+        substNames' [] [] e = return e
+        substNames' _ _ _ = Nothing
+
     tcDefineFun :: QName -> [R.Clause] -> UnquoteM Term
     tcDefineFun x cs = inOriginalContext $ (setDirty >>) $ liftTCM $ do
       whenM (isLeft <$> getConstInfo' x) $
@@ -961,7 +1048,10 @@ evalTCM v = do
       Right cands -> liftTCM $
         buildList <*> mapM (quoteTerm . candidateTerm) cands
 
-
+    splitPars :: Int -> A.Expr -> ([A.TypedBinding], A.Expr)
+    splitPars 0 e = ([] , e)
+    splitPars npars (A.Pi _ (n :| _) e) = first (n :) (splitPars (npars - 1) e)
+    splitPars npars e = __IMPOSSIBLE__
 ------------------------------------------------------------------------
 -- * Trusted executables
 ------------------------------------------------------------------------
-- 
2.31.0

From bb475ac5bcd2bb4865b1ae522d704b07977e3357 Mon Sep 17 00:00:00 2001
From: Liang-Ting Chen <liang.ting.chen.tw@gmail.com>
Date: Mon, 27 Jun 2022 15:04:55 +0800
Subject: [PATCH] `unquoteDecl data` takes exactly one datatype name

---
 src/full/Agda/Syntax/Abstract.hs                       | 2 +-
 src/full/Agda/Syntax/Abstract/Views.hs                 | 2 +-
 src/full/Agda/Syntax/Concrete.hs                       | 3 ++-
 src/full/Agda/Syntax/Concrete/Definitions.hs           | 2 +-
 src/full/Agda/Syntax/Concrete/Definitions/Types.hs     | 2 +-
 src/full/Agda/Syntax/Concrete/Fixity.hs                | 2 +-
 src/full/Agda/Syntax/Parser/Parser.y                   | 5 ++---
 src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs | 7 ++-----
 src/full/Agda/TypeChecking/Rules/Decl.hs               | 6 +++---
 9 files changed, 14 insertions(+), 17 deletions(-)

diff --git a/src/full/Agda/Syntax/Abstract.hs b/src/full/Agda/Syntax/Abstract.hs
index a7f18b16b..8ddb97034 100644
--- a/src/full/Agda/Syntax/Abstract.hs
+++ b/src/full/Agda/Syntax/Abstract.hs
@@ -189,7 +189,7 @@ data Declaration
       -- ^ Only for highlighting purposes
   | UnquoteDecl MutualInfo [DefInfo] [QName] Expr
   | UnquoteDef  [DefInfo] [QName] Expr
-  | UnquoteData [DefInfo] [QName] UniverseCheck [DefInfo] [QName] Expr
+  | UnquoteData [DefInfo] QName UniverseCheck [DefInfo] [QName] Expr
   | ScopedDecl ScopeInfo [Declaration]  -- ^ scope annotation
   deriving (Data, Show, Generic)
 
diff --git a/src/full/Agda/Syntax/Abstract/Views.hs b/src/full/Agda/Syntax/Abstract/Views.hs
index 4dc9ed7bf..28dae3be8 100644
--- a/src/full/Agda/Syntax/Abstract/Views.hs
+++ b/src/full/Agda/Syntax/Abstract/Views.hs
@@ -491,7 +491,7 @@ instance DeclaredNames Declaration where
       PatternSynDef q _ _          -> singleton (WithKind PatternSynName q)
       UnquoteDecl _ _ qs _         -> fromList $ map (WithKind OtherDefName) qs  -- could be Fun or Axiom
       UnquoteDef _ qs _            -> fromList $ map (WithKind FunName) qs       -- cannot be Axiom
-      UnquoteData _ xs _ _ cs _    -> fromList $ map (WithKind DataName) xs ++ map (WithKind ConName) cs
+      UnquoteData _ d _ _ cs _     -> singleton (WithKind DataName d) <> (fromList $ map (WithKind ConName) cs) -- singleton _ <> map (WithKind ConName) cs
       FunDef _ q _ cls             -> singleton (WithKind FunName q) <> declaredNames cls
       ScopedDecl _ decls           -> declaredNames decls
       Section _ _ _ decls          -> declaredNames decls
diff --git a/src/full/Agda/Syntax/Concrete.hs b/src/full/Agda/Syntax/Concrete.hs
index 54bf6e5ce..df57af354 100644
--- a/src/full/Agda/Syntax/Concrete.hs
+++ b/src/full/Agda/Syntax/Concrete.hs
@@ -482,7 +482,8 @@ data Declaration
       -- ^ @unquoteDecl xs = e@
   | UnquoteDef  Range [Name] Expr
       -- ^ @unquoteDef xs = e@
-  | UnquoteData Range [Name] [Name] Expr
+  | UnquoteData Range Name [Name] Expr
+      -- ^ @unquoteDecl data d constructor xs = e@
   | Pragma      Pragma
   deriving (Data, Eq)
 
diff --git a/src/full/Agda/Syntax/Concrete/Definitions.hs b/src/full/Agda/Syntax/Concrete/Definitions.hs
index e01bc6e6a..3de32fe77 100644
--- a/src/full/Agda/Syntax/Concrete/Definitions.hs
+++ b/src/full/Agda/Syntax/Concrete/Definitions.hs
@@ -155,7 +155,7 @@ declKind (NiceRecSig r _ _ pc uc x pars _)   = LoneSigDecl r (RecName pc uc) x
 declKind (NiceDataSig r _ _ pc uc x pars _)  = LoneSigDecl r (DataName pc uc) x
 declKind (FunDef r _ abs ins tc cc x _)      = LoneDefs (FunName tc cc) [x]
 declKind (NiceDataDef _ _ _ pc uc x pars _)  = LoneDefs (DataName pc uc) [x]
-declKind (NiceUnquoteData _ _ _ pc uc xs _ _) = LoneDefs (DataName pc uc) xs
+declKind (NiceUnquoteData _ _ _ pc uc x _ _) = LoneDefs (DataName pc uc) [x]
 declKind (NiceRecDef _ _ _ pc uc x _ pars _) = LoneDefs (RecName pc uc) [x]
 declKind (NiceUnquoteDef _ _ _ tc cc xs _)   = LoneDefs (FunName tc cc) xs
 declKind Axiom{}                             = OtherDecl
diff --git a/src/full/Agda/Syntax/Concrete/Definitions/Types.hs b/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
index ad14a9744..a36d937d0 100644
--- a/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
+++ b/src/full/Agda/Syntax/Concrete/Definitions/Types.hs
@@ -80,7 +80,7 @@ data NiceDeclaration
   | NiceGeneralize Range Access ArgInfo TacticAttribute Name Expr
   | NiceUnquoteDecl Range Access IsAbstract IsInstance TerminationCheck CoverageCheck [Name] Expr
   | NiceUnquoteDef Range Access IsAbstract TerminationCheck CoverageCheck [Name] Expr
-  | NiceUnquoteData Range Access IsAbstract PositivityCheck UniverseCheck [Name] [Name] Expr
+  | NiceUnquoteData Range Access IsAbstract PositivityCheck UniverseCheck Name [Name] Expr
   deriving (Data, Show, Generic)
 
 instance NFData NiceDeclaration
diff --git a/src/full/Agda/Syntax/Concrete/Fixity.hs b/src/full/Agda/Syntax/Concrete/Fixity.hs
index effa6bedf..886ddc34b 100644
--- a/src/full/Agda/Syntax/Concrete/Fixity.hs
+++ b/src/full/Agda/Syntax/Concrete/Fixity.hs
@@ -242,7 +242,7 @@ declaredNames = \case
   Module{}              -> mempty
   UnquoteDecl _ xs _    -> declaresNames xs
   UnquoteDef{}          -> mempty
-  UnquoteData _ xs cs _ -> declaresNames (xs ++ cs)
+  UnquoteData _ x cs _  -> declaresNames (x:cs)
   -- BUILTIN pragmas which do not require an accompanying definition declare
   -- the (unqualified) name they mention.
   Pragma (BuiltinPragma _ b (QName x))
diff --git a/src/full/Agda/Syntax/Parser/Parser.y b/src/full/Agda/Syntax/Parser/Parser.y
index 369d36e34..87f5ed63c 100644
--- a/src/full/Agda/Syntax/Parser/Parser.y
+++ b/src/full/Agda/Syntax/Parser/Parser.y
@@ -1307,9 +1307,8 @@ Primitive : 'primitive' ArgTypeSignaturesOrEmpty  {
 UnquoteDecl :: { Declaration }
 UnquoteDecl
   : 'unquoteDecl' '=' Expr { UnquoteDecl (fuseRange $1 $3) [] $3 }
-  | 'unquoteDecl' 'data' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $5)) (List1.toList $3) [] $5 }
-  | 'unquoteDecl' 'constructor' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $5)) [] (List1.toList $3) $5 }
-  | 'unquoteDecl' 'data' SpaceIds 'constructor' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $4, $7)) (List1.toList $3) (List1.toList $5) $7 }
+  | 'unquoteDecl' 'data' Id '=' Expr { UnquoteData (getRange($1, $2, $5)) $3 [] $5 }
+  | 'unquoteDecl' 'data' Id 'constructor' SpaceIds '=' Expr { UnquoteData (getRange($1, $2, $4, $7)) $3 (List1.toList $5) $7 }
   | 'unquoteDecl' SpaceIds '=' Expr { UnquoteDecl (fuseRange $1 $4) (List1.toList $2) $4 }
   | 'unquoteDef'  SpaceIds '=' Expr { UnquoteDef (fuseRange $1 $4) (List1.toList $2) $4 }
 
diff --git a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
index b37d32aa8..c1e3007c9 100644
--- a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
+++ b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
@@ -2042,10 +2042,7 @@ instance ToAbstract NiceDeclaration where
       zipWithM_ (rebindName p OtherDefName) xs ys
       return [ A.UnquoteDef [ mkDefInfo x fx PublicAccess a r | (fx, x) <- zip fxs xs ] ys e ]
 
-    NiceUnquoteData r p a pc uc xs cs e -> do
-      x <- maybe (typeError $ GenericError $ "Cannot unquote multiple data names at once")
-                 (return . List1.head)
-                 (List1.nonEmpty xs)
+    NiceUnquoteData r p a pc uc x cs e -> do
       fx <- getConcreteFixity x
       x' <- freshAbstractQName fx x
       bindName p QuotableName x x'
@@ -2068,7 +2065,7 @@ instance ToAbstract NiceDeclaration where
       return
         [ A.Mutual
           mi [A.UnquoteData
-            [ mkDefInfo x fx p a r ] [x'] uc
+            [ mkDefInfo x fx p a r ] x' uc
             [ mkDefInfo c fc p a r | (fc, c) <- zip fcs cs] cs' e ]
         ]
 
diff --git a/src/full/Agda/TypeChecking/Rules/Decl.hs b/src/full/Agda/TypeChecking/Rules/Decl.hs
index 2e78d7634..97a951bb2 100644
--- a/src/full/Agda/TypeChecking/Rules/Decl.hs
+++ b/src/full/Agda/TypeChecking/Rules/Decl.hs
@@ -193,9 +193,9 @@ checkDecl d = setCurrentRange d $ do
       -- TODO: Benchmarking for unquote.
       A.UnquoteDecl mi is xs e -> checkMaybeAbstractly is $ checkUnquoteDecl mi is xs e
       A.UnquoteDef is xs e     -> impossible $ checkMaybeAbstractly is $ checkUnquoteDef is xs e
-      A.UnquoteData is xs uc js cs e -> checkMaybeAbstractly (is ++ js) $ do
-        reportSDoc "tc.unquote.data" 20 $ "Checking unquoteDecl data" <+> sep (map prettyTCM xs)
-        Nothing <$ unquoteTop (xs ++ cs) e
+      A.UnquoteData is x uc js cs e -> checkMaybeAbstractly (is ++ js) $ do
+        reportSDoc "tc.unquote.data" 20 $ "Checking unquoteDecl data" <+> prettyTCM x
+        Nothing <$ unquoteTop (x:cs) e
 
     whenNothingM (asksTC envMutualBlock) $ do
 
-- 
2.31.0

From 47eb2320689b6d354c6391201d94a5f4b17efe5f Mon Sep 17 00:00:00 2001
From: Viktor Lin <hi@viktorl.in>
Date: Mon, 27 Jun 2022 22:30:14 +0800
Subject: [PATCH] [ reflection ] fix module names of constructors defined by
 `unquoteDecl`

---
 src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
index c1e3007c9..5c597bc00 100644
--- a/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
+++ b/src/full/Agda/Syntax/Translation/ConcreteToAbstract.hs
@@ -2053,11 +2053,12 @@ instance ToAbstract NiceDeclaration where
       createModule (Just IsDataModule) m
       bindModule p x m  -- make it a proper module
 
-      cs' <- withCurrentModule m $ mapM (bindUnquoteConstructorName m p) cs
+      cs' <- mapM (bindUnquoteConstructorName m p) cs
 
       e <- withCurrentModule m $ toAbstract e
 
       rebindName p DataName x x'
+      zipWithM_ (rebindName p ConName) cs cs'
       withCurrentModule m $ zipWithM_ (rebindName p ConName) cs cs'
 
       fcs <- mapM getConcreteFixity cs
-- 
2.31.0

