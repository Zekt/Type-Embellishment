%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Josh Ko at 2022-06-30 17:16:24 +0800 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{Filinski-semantic-partial-evaluation,
	abstract = {We formally characterize partial evaluation of functional programs as a normalization problem in an equational theory, and derive a type-based normalization-by-evaluation algorithm for computing normal forms in this setting. We then establish the correctness of this algorithm using a semantic argument based on Kripke logical relations. For simplicity, the results are stated for a non-strict, purely functional language; but the methods are directly applicable to stating and proving correctness of type-directed partial evaluation in ML-like languages as well.},
	author = {Filinski, Andrzej},
	booktitle = {International Conference on Principles and Practice of Declarative Programming (PPDP)},
	date-added = {2022-06-17 09:58:17 +0800},
	date-modified = {2022-06-17 09:58:17 +0800},
	doi = {10.1007/10704567_23},
	pages = {378--395},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {A Semantic Account of Type-Directed Partial Evaluation},
	volume = {1702},
	year = 1999,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCuLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0ZpbGluc2tpIDE5OTkgLSBBIFNlbWFudGljIEFjY291bnQgb2YgVHlwZS1EaXJlY3RlZCBQYXJ0aWFsIEV2YWx1YXRpb24ucGRmTxECxgAAAAACxgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0ZpbGluc2tpIDE5OTkgLSBBICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAK4vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6RmlsaW5za2kgMTk5OSAtIEEgU2VtYW50aWMgQWNjb3VudCBvZiBUeXBlLURpcmVjdGVkIFBhcnRpYWwgRXZhbHVhdGlvbi5wZGYADgCWAEoARgBpAGwAaQBuAHMAawBpACAAMQA5ADkAOQAgAC0AIABBACAAUwBlAG0AYQBuAHQAaQBjACAAQQBjAGMAbwB1AG4AdAAgAG8AZgAgAFQAeQBwAGUALQBEAGkAcgBlAGMAdABlAGQAIABQAGEAcgB0AGkAYQBsACAARQB2AGEAbAB1AGEAdABpAG8AbgAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIArFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvRmlsaW5za2kgMTk5OSAtIEEgU2VtYW50aWMgQWNjb3VudCBvZiBUeXBlLURpcmVjdGVkIFBhcnRpYWwgRXZhbHVhdGlvbi5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQA1QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAOf}}

@inproceedings{Magalhaes-GGP,
	abstract = {Generic programming (GP) is a form of abstraction in programming languages that serves to reduce code duplication by exploiting the regular structure of algebraic datatypes. Over the years, several different approaches to GP in Haskell have surfaced. These approaches are often similar, but certain differences make them particularly well-suited for one specific domain or application. As such, there is a lot of code duplication across GP libraries, which is rather unfortunate, given the original goals of GP.\par

To address this problem, we define conversions from one popular GP library representation to several others. Our work unifies many approaches to GP, and simplifies the life of both library writers and users. Library writers can define their approach as a conversion from our library, obviating the need for writing meta-programming code for generation of conversions to and from the generic representation. Users of GP, who often struggle to find ``the right approach'' to use, can now mix and match functionality from different libraries with ease, and need not worry about having multiple (potentially inefficient and large) code blocks for generic representations in different approaches.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro and L{\"o}h, Andres},
	booktitle = {International Symposium on Practical Aspects of Declarative Languages (PADL)},
	date-added = {2022-06-17 09:54:43 +0800},
	date-modified = {2022-06-17 09:54:43 +0800},
	doi = {10.1007/978-3-319-04132-2_15},
	pages = {216-231},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Generic Generic Programming},
	volume = {8324},
	year = 2014,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCbAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgAGUAdAAgAGEAbAAgADIAMAAxADQAIAAtACAARwBlAG4AZQByAGkAYwAgAEcAZQBuAGUAcgBpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZk8RAnwAAAAAAnwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////xRNYWdhbGhhI0ZGRkZGRkZGLnBkZi0gR2VuZXJpYyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCcLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5Ok1hZ2FsaGHMg2VzIGV0IGFsIDIwMTQgLSBHZW5lcmljIEdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmAA4AcAA3AE0AYQBnAGEAbABoAGEDAwBlAHMAIABlAHQAIABhAGwAIAAyADAAMQA0ACAALQAgAEcAZQBuAGUAcgBpAGMAIABHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBtAGkAbgBnAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCaVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYWdhbGhhzINlcyBldCBhbCAyMDE0IC0gR2VuZXJpYyBHZW5lcmljIFByb2dyYW1taW5nLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAFdAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA90=}}

@inproceedings{Sozeau-universe-polymorphism-Coq,
	abstract = {Universes are used in Type Theory to ensure consistency by checking that definitions are well-stratified according to a certain hierarchy. In the case of the \textsc{Coq} proof assistant, based on the predicative Calculus of Inductive Constructions (pCIC), this hierachy is built from an impredicative sort \texttt{Prop} and an infinite number of predicative \texttt{Type}$_i$ universes. A cumulativity relation represents the inclusion order of universes in the core theory. Originally, universes were thought to be floating levels, and definitions to implicitely constrain these levels in a consistent manner. This works well for most theories, however the globality of levels and constraints precludes \emph{generic} constructions on universes that could work at different levels. Universe polymorphism extends this setup by adding \emph{local} bindings of universes and constraints, supporting generic definitions over universes, reusable at different levels. This provides the same kind of code reuse facilities as ML-style parametric polymorphism. However, the structure and hierarchy of universes is more complex than bare polymorphic type variables. In this paper, we introduce a conservative extension of pCIC supporting universe polymorphism and treating its whole hierarchy. This new design supports typical ambiguity and implicit polymorphic generalization at the same time, keeping it mostly transparent to the user. Benchmarking the implementation as an extension of the \textsc{Coq} proof assistant on real-world examples gives encouraging results.},
	author = {Sozeau, Matthieu and Tabareau, Nicolas},
	booktitle = {International Conference on Interactive Theorem Proving (ITP)},
	date-added = {2022-06-13 22:27:03 +0800},
	date-modified = {2022-06-13 22:27:03 +0800},
	doi = {10.1007/978-3-319-08970-6_32},
	pages = {499--514},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Universe Polymorphism in {Coq}},
	volume = {8558},
	year = 2014,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCYLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1NvemVhdSBldCBhbCAyMDE0IC0gVW5pdmVyc2UgUG9seW1vcnBoaXNtIGluIENvcS5wZGZPEQJuAAAAAAJuAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fU296ZWF1IGV0IGFsIDIwMTQgI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAmC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpTb3plYXUgZXQgYWwgMjAxNCAtIFVuaXZlcnNlIFBvbHltb3JwaGlzbSBpbiBDb3EucGRmAA4AagA0AFMAbwB6AGUAYQB1ACAAZQB0ACAAYQBsACAAMgAwADEANAAgAC0AIABVAG4AaQB2AGUAcgBzAGUAIABQAG8AbAB5AG0AbwByAHAAaABpAHMAbQAgAGkAbgAgAEMAbwBxAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCWVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Tb3plYXUgZXQgYWwgMjAxNCAtIFVuaXZlcnNlIFBvbHltb3JwaGlzbSBpbiBDb3EucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL8AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==}}

@article{Fiore-SOAS-Agda,
	abstract = {Despite extensive research both on the theoretical and practical fronts, formalising, reasoning about, and implementing languages with variable binding is still a daunting endeavour -- repetitive boilerplate and the overly complicated metatheory of capture-avoiding substitution often get in the way of progressing on to the actually interesting properties of a language. Existing developments offer some relief, however at the expense of inconvenient and error-prone term encodings and lack of formal foundations.\par

We present a mathematically-inspired language-formalisation framework implemented in Agda. The system translates the description of a syntax signature with variable-binding operators into an intrinsically-encoded, inductive data type equipped with syntactic operations such as weakening and substitution, along with their correctness properties. The generated metatheory further incorporates metavariables and their associated operation of metasubstitution, which enables second-order equational/rewriting reasoning. The underlying mathematical foundation of the framework -- initial algebra semantics -- derives compositional interpretations of languages into their models satisfying the semantic substitution lemma by construction.},
	author = {Fiore, Marcelo and Szamozvancev, Dmitrij},
	date-added = {2022-06-13 13:57:47 +0800},
	date-modified = {2022-06-13 13:57:47 +0800},
	doi = {10.1145/3498715},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {53:1--29},
	title = {Formal Metatheory of Second-Order Abstract Syntax},
	volume = {6},
	year = {2022},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCsLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Zpb3JlIGV0IGFsIDIwMjIgLSBGb3JtYWwgTWV0YXRoZW9yeSBvZiBTZWNvbmQtT3JkZXIgQWJzdHJhY3QgU3ludGF4LnBkZk8RAr4AAAAAAr4AAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9GaW9yZSBldCBhbCAyMDIyIC0jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCsLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkZpb3JlIGV0IGFsIDIwMjIgLSBGb3JtYWwgTWV0YXRoZW9yeSBvZiBTZWNvbmQtT3JkZXIgQWJzdHJhY3QgU3ludGF4LnBkZgAOAJIASABGAGkAbwByAGUAIABlAHQAIABhAGwAIAAyADAAMgAyACAALQAgAEYAbwByAG0AYQBsACAATQBlAHQAYQB0AGgAZQBvAHIAeQAgAG8AZgAgAFMAZQBjAG8AbgBkAC0ATwByAGQAZQByACAAQQBiAHMAdAByAGEAYwB0ACAAUwB5AG4AdABhAHgALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAKpVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Zpb3JlIGV0IGFsIDIwMjIgLSBGb3JtYWwgTWV0YXRoZW9yeSBvZiBTZWNvbmQtT3JkZXIgQWJzdHJhY3QgU3ludGF4LnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJADTAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA5U=}}

@misc{Yang-recursion-schemes,
	abstract = {This document is a `dictionary' of \emph{structured recursion schemes} in functional programming. Each recursion scheme is motivated and explained with concrete programming examples in Haskell, and the dual of each recursion scheme is also presented.},
	author = {Yang, Zhixuan and Wu, Nicolas},
	date-added = {2022-03-01 16:27:21 +0800},
	date-modified = {2022-06-15 22:26:05 +0800},
	howpublished = {To appear at the \textit{International Conference on Mathematics of Program Construction (MPC)}},
	title = {Fantastic Morphisms and Where to Find Them: A Guide to Recursion Schemes},
	url = {https://arxiv.org/abs/2202.13633},
	year = {2022},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxDBLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1lhbmcgZXQgYWwgMjAyMiAtIEZhbnRhc3RpYyBNb3JwaGlzbXMgYW5kIFdoZXJlIHRvIEZpbmQgVGhlbSBBIEd1aWRlIHRvIFJlY3Vyc2lvbiBTY2hlbWVzLnBkZk8RAxQAAAAAAxQAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9ZYW5nIGV0IGFsIDIwMjIgLSAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgDBLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OllhbmcgZXQgYWwgMjAyMiAtIEZhbnRhc3RpYyBNb3JwaGlzbXMgYW5kIFdoZXJlIHRvIEZpbmQgVGhlbSBBIEd1aWRlIHRvIFJlY3Vyc2lvbiBTY2hlbWVzLnBkZgAADgC8AF0AWQBhAG4AZwAgAGUAdAAgAGEAbAAgADIAMAAyADIAIAAtACAARgBhAG4AdABhAHMAdABpAGMAIABNAG8AcgBwAGgAaQBzAG0AcwAgAGEAbgBkACAAVwBoAGUAcgBlACAAdABvACAARgBpAG4AZAAgAFQAaABlAG0AIABBACAARwB1AGkAZABlACAAdABvACAAUgBlAGMAdQByAHMAaQBvAG4AIABTAGMAaABlAG0AZQBzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgC/VXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9ZYW5nIGV0IGFsIDIwMjIgLSBGYW50YXN0aWMgTW9ycGhpc21zIGFuZCBXaGVyZSB0byBGaW5kIFRoZW0gQSBHdWlkZSB0byBSZWN1cnNpb24gU2NoZW1lcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAOgAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEAA==}}

@misc{Agda-stdlib,
	author = {{Agda Team}, {The}},
	date-added = {2022-02-27 19:58:53 +0800},
	date-modified = {2022-02-28 10:17:14 +0800},
	howpublished = {\url{https://github.com/agda/agda-stdlib/tree/v1.7.1}},
	note = {Accessed: 2022-02-27},
	title = {The {Agda} Standard Library (Version 1.7.1)},
	year = {2022}}

@incollection{Altenkirch-SSDGP,
	abstract = {$\emptyset$},
	author = {Altenkirch, Thorsten and McBride, Conor and Morris, Peter},
	booktitle = {International Spring School on Datatype-Generic Programming (SSDGP) 2006},
	date-added = {2022-02-26 10:59:07 +0800},
	date-modified = {2022-02-26 10:59:07 +0800},
	doi = {10.1007/978-3-540-76786-2_4},
	pages = {209--257},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Generic Programming with Dependent Types},
	volume = {4719},
	year = 2007,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCoLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsdGVua2lyY2ggZXQgYWwgMjAwNyAtIEdlbmVyaWMgUHJvZ3JhbW1pbmcgd2l0aCBEZXBlbmRlbnQgVHlwZXMucGRmTxECrgAAAAACrgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0FsdGVua2lyY2ggZXQgYWwgMiNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKgvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QWx0ZW5raXJjaCBldCBhbCAyMDA3IC0gR2VuZXJpYyBQcm9ncmFtbWluZyB3aXRoIERlcGVuZGVudCBUeXBlcy5wZGYADgCKAEQAQQBsAHQAZQBuAGsAaQByAGMAaAAgAGUAdAAgAGEAbAAgADIAMAAwADcAIAAtACAARwBlAG4AZQByAGkAYwAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAHcAaQB0AGgAIABEAGUAcABlAG4AZABlAG4AdAAgAFQAeQBwAGUAcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAplVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQWx0ZW5raXJjaCBldCBhbCAyMDA3IC0gR2VuZXJpYyBQcm9ncmFtbWluZyB3aXRoIERlcGVuZGVudCBUeXBlcy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAzwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAOB}}

@incollection{Abou-Saleh-BX-intro,
	abstract = {Bidirectional transformations (BX) serve to maintain consistency between different representations of related and often overlapping information, translating changes in one representation to the others. We present a brief introduction to the field, in order to provide some common background to the remainder of this volume, which constitutes the lecture notes from the \emph{Summer School on Bidirectional Transformations}, held in Oxford in July 2016 as one of the closing activities of the UK EPSRC-funded project \emph{A Theory of Least Change for Bidirectional Transformations}.},
	author = {Abou-Saleh, Faris and Cheney, James and Gibbons, Jeremy and McKinna, James and Stevens, Perdita},
	booktitle = {International Summer School on Bidirectional Transformations (SSBX) 2016},
	chapter = {1},
	date-added = {2022-02-26 10:56:49 +0800},
	date-modified = {2022-02-26 10:56:49 +0800},
	doi = {10.1007/978-3-319-79108-1_1},
	pages = {1-28},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Introduction to Bidirectional Transformations},
	volume = {9715},
	year = {2018},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCtLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Fib3UtU2FsZWggZXQgYWwgMjAxOCAtIEludHJvZHVjdGlvbiB0byBCaWRpcmVjdGlvbmFsIFRyYW5zZm9ybWF0aW9ucy5wZGZPEQLEAAAAAALEAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fQWJvdS1TYWxlaCBldCBhbCAyI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIArS86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpBYm91LVNhbGVoIGV0IGFsIDIwMTggLSBJbnRyb2R1Y3Rpb24gdG8gQmlkaXJlY3Rpb25hbCBUcmFuc2Zvcm1hdGlvbnMucGRmAAAOAJQASQBBAGIAbwB1AC0AUwBhAGwAZQBoACAAZQB0ACAAYQBsACAAMgAwADEAOAAgAC0AIABJAG4AdAByAG8AZAB1AGMAdABpAG8AbgAgAHQAbwAgAEIAaQBkAGkAcgBlAGMAdABpAG8AbgBhAGwAIABUAHIAYQBuAHMAZgBvAHIAbQBhAHQAaQBvAG4AcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAq1VzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQWJvdS1TYWxlaCBldCBhbCAyMDE4IC0gSW50cm9kdWN0aW9uIHRvIEJpZGlyZWN0aW9uYWwgVHJhbnNmb3JtYXRpb25zLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQA1AAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAOc}}

@incollection{Gibbons-DGP,
	abstract = {\emph{Generic programming} aims to increase the flexibility of programming languages, by expanding the possibilities for parametrization --- ideally, without also expanding the possibilities for uncaught errors. The term means different things to different people: \emph{parametric polymorphism}, \emph{data abstraction}, \emph{meta-programming}, and so on. We use it to mean polytypism, that is, parametrization by the \emph{shape} of data structures rather than their contents. To avoid confusion with other uses, we have coined the qualified term \emph{datatype-generic programming} for this purpose. In these lecture notes, we expand on the definition of datatype-generic programming, and present some examples of datatype-generic programs. We also explore the connection with \emph{design patterns} in object-oriented programming; in particular, we argue that certain design patterns are just higher-order datatype-generic programs.},
	author = {Gibbons, Jeremy},
	booktitle = {International Spring School on Datatype-Generic Programming (SSDGP) 2006},
	date-added = {2022-02-26 10:38:06 +0800},
	date-modified = {2022-02-26 10:38:06 +0800},
	doi = {10.1007/978-3-540-76786-2_1},
	pages = {1--71},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Datatype-Generic Programming},
	volume = {4719},
	year = {2007},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCTLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0dpYmJvbnMgMjAwNyAtIERhdGF0eXBlLUdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmTxECXAAAAAACXAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0dpYmJvbnMgMjAwNyAtIERhdCNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJMvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6R2liYm9ucyAyMDA3IC0gRGF0YXR5cGUtR2VuZXJpYyBQcm9ncmFtbWluZy5wZGYAAA4AYAAvAEcAaQBiAGIAbwBuAHMAIAAyADAAMAA3ACAALQAgAEQAYQB0AGEAdAB5AHAAZQAtAEcAZQBuAGUAcgBpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJFVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0dpYmJvbnMgMjAwNyAtIERhdGF0eXBlLUdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAC6AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAxo=}}

@inproceedings{Nanevski-names-and-necessity,
	abstract = {Meta-programming languages provide infrastructure to generate and execute object programs at run-time. In a typed setting, they contain a modal type constructor which classifies object code. These code types generally come in two flavors: closed and open. Closed code expressions can be invoked at run-time, but the computations over them are more rigid, and typically produce less efficient residual object programs. Open code provides better inlining and partial evaluation of object programs, but once constructed, expressions of this type cannot in general be evaluated.\par

Recent work in this area has focused on combining the two notions into a sound system. We present a novel way to achieve this. It is based on adding the notion of \emph{names} from the work on Nominal Logic and FreshML to the $\lambda^\Box$-calculus of proof terms for the \emph{necessity} fragment of modal logic S4. The resulting language provides a more fine-grained control over free variables of object programs when compared to the existing languages for meta-programming. In addition, this approach lends itself well to addition of intensional code analysis, i.e. ability of meta programs to inspect and destruct object programs at run-time in a type-safe manner, which we also undertake.},
	author = {Aleksandar Nanevski},
	booktitle = {International Conference on Functional programming (ICFP)},
	date-added = {2022-02-25 15:01:08 +0800},
	date-modified = {2022-02-25 15:01:08 +0800},
	doi = {10.1145/581478.581498},
	pages = {206--217},
	publisher = {ACM},
	title = {Meta-programming with Names and Necessity},
	year = 2002,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxChLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L05hbmV2c2tpIDIwMDIgLSBNZXRhLXByb2dyYW1taW5nIHdpdGggTmFtZXMgYW5kIE5lY2Vzc2l0eS5wZGZPEQKUAAAAAAKUAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fTmFuZXZza2kgMjAwMiAtIE1lI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAoS86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpOYW5ldnNraSAyMDAyIC0gTWV0YS1wcm9ncmFtbWluZyB3aXRoIE5hbWVzIGFuZCBOZWNlc3NpdHkucGRmAAAOAHwAPQBOAGEAbgBlAHYAcwBrAGkAIAAyADAAMAAyACAALQAgAE0AZQB0AGEALQBwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIAB3AGkAdABoACAATgBhAG0AZQBzACAAYQBuAGQAIABOAGUAYwBlAHMAcwBpAHQAeQAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAn1VzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTmFuZXZza2kgMjAwMiAtIE1ldGEtcHJvZ3JhbW1pbmcgd2l0aCBOYW1lcyBhbmQgTmVjZXNzaXR5LnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQAyAAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANg}}

@phdthesis{Magalhaes-thesis,
	abstract = {Abstraction is ubiquitous in computer programming. The work of this thesis focuses on one specific form of abstraction. Computer programs manipulate data, which can either be primitive machine data (such as integer or fractional numbers) or programmer-defined data (such as lists, trees, matrices, images, etc.). There is only a small number of primitive datatypes, but a potentially infinite number of programmer-defined data. The structure of the latter data depends on the problem at hand, and while some structures appear very often (such as sequences of values), others are truly specific to a particular problem.\par

Some kind of functionality is generally desired for all types of data. Reading and storing files to the disk, for instance, is as important for machine integers as it is for complex healthcare databases, or genealogy trees. And not just reading and writing files: testing for equality, sorting, traversing, computing the length, all are examples of functionality that is often desired for all kinds of data. Most programming languages allow defining complex datatypes as a form of abstraction, but few provide good support for defining behaviour that is generic over data. As such, programmers are forced to specify this behaviour over and over again, once for each new type of data, and also to adapt this code whenever the structure of their data changes. This is a tedious task, and can quickly become time-consuming, leading some programmers to write programs to generate this type of functionality automatically from the structure of data.\par

We think that a programming language should allow programmers to define generic programs, which specify behaviour that is generic over the type of data. Moreover, it should automatically provide generic behaviour for new data, eliminating the need for repeated writing and rewriting of trivial code that just specialises general behaviour to a particular type of data. It should do so in a convenient way for the programmer, leading to more abstract and concise programs, while remaining clear and efficient. This leads us to the two research questions we set out to answer:
\begin{enumerate}
\item There are many different approaches to generic programming, varying in complexity and expressiveness. How can we better understand each of the approaches, and the way they relate to each other?
\item Poor runtime efficiency, insufficient datatype support, and lack of proper language integration are often pointed out as deficiencies in generic programming implementations. How can we best address these concerns?
\end{enumerate}
We answer the first question in the first part of this thesis. We start by picking a number of generic programming approaches and define a concise model for each of them. We then use this model to formally express how to embed the structural representation of data of one approach into another, allowing us to better understand the relation between different approaches. The second part of this thesis deals with answering the second question, devoting one chapter to analysing and mitigating each of the practical concerns.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro},
	date-added = {2022-02-25 09:54:05 +0800},
	date-modified = {2022-02-25 09:54:05 +0800},
	school = {Utrecht University},
	title = {Less Is More: Generic Programming Theory and Practice},
	url = {https://dreixel.net/research/pdf/thesis.pdf},
	year = {2012},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCuAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgADIAMAAxADIAIAAtACAATABlAHMAcwAgAEkAcwAgAE0AbwByAGUAIABHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAVABoAGUAbwByAHkAIABhAG4AZAAgAFAAcgBhAGMAdABpAGMAZQAuAHAAZABmTxECygAAAAACygACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////FE1hZ2FsaGEjRkZGRkZGRkYucGRmIElzIE1vcmUgRwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAK8vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWFnYWxoYcyDZXMgMjAxMiAtIExlc3MgSXMgTW9yZSBHZW5lcmljIFByb2dyYW1taW5nIFRoZW9yeSBhbmQgUHJhY3RpY2UucGRmAAAOAJYASgBNAGEAZwBhAGwAaABhAwMAZQBzACAAMgAwADEAMgAgAC0AIABMAGUAcwBzACAASQBzACAATQBvAHIAZQAgAEcAZQBuAGUAcgBpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABUAGgAZQBvAHIAeQAgAGEAbgBkACAAUAByAGEAYwB0AGkAYwBlAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCtVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYWdhbGhhzINlcyAyMDEyIC0gTGVzcyBJcyBNb3JlIEdlbmVyaWMgUHJvZ3JhbW1pbmcgVGhlb3J5IGFuZCBQcmFjdGljZS5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAYMAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEUQ==}}

@inproceedings{Magalhaes-inlining,
	abstract = {It is known that datatype-generic programs often run slower than type-specific variants, and this factor can prevent adoption of generic programming altogether. There can be multiple reasons for the performance penalty, but often it is caused by conversions to and from representation types that do not get eliminated during compilation. However, it is also known that generic functions can be specialised to specific datatypes, removing any overhead from the use of generic programming. In this paper, we investigate compilation techniques to specialise generic functions and remove the performance overhead of generic programs in Haskell. We pick a representative generic programming library and look at the generated code for a number of example generic functions. After understanding the necessary compiler optimisations for producing efficient generic code, we benchmark the runtime of our generic functions against handwritten variants, and conclude that the overhead can indeed be removed automatically by the compiler.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro},
	booktitle = {Symposium on Implementation and Application of Functional Languages (IFL)},
	date-added = {2022-02-24 17:53:16 +0800},
	date-modified = {2022-02-24 17:53:16 +0800},
	doi = {10.1007/978-3-642-41582-1_7},
	pages = {104--121},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Optimisation of Generic Programs through Inlining},
	volume = {8241},
	year = 2013,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCrAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgADIAMAAxADMAIAAtACAATwBwAHQAaQBtAGkAcwBhAHQAaQBvAG4AIABvAGYAIABHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBzACAAdABoAHIAbwB1AGcAaAAgAEkAbgBsAGkAbgBpAG4AZwAuAHAAZABmTxECvAAAAAACvAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////FE1hZ2FsaGEjRkZGRkZGRkYucGRmbWlzYXRpb24gbwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWFnYWxoYcyDZXMgMjAxMyAtIE9wdGltaXNhdGlvbiBvZiBHZW5lcmljIFByb2dyYW1zIHRocm91Z2ggSW5saW5pbmcucGRmAA4AkABHAE0AYQBnAGEAbABoAGEDAwBlAHMAIAAyADAAMQAzACAALQAgAE8AcAB0AGkAbQBpAHMAYQB0AGkAbwBuACAAbwBmACAARwBlAG4AZQByAGkAYwAgAFAAcgBvAGcAcgBhAG0AcwAgAHQAaAByAG8AdQBnAGgAIABJAG4AbABpAG4AaQBuAGcALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAKpVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01hZ2FsaGHMg2VzIDIwMTMgLSBPcHRpbWlzYXRpb24gb2YgR2VuZXJpYyBQcm9ncmFtcyB0aHJvdWdoIElubGluaW5nLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAF9AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABD0=}}

@inproceedings{Magalhaes-generic-libraries,
	abstract = {Datatype-generic programming increases program abstraction and reuse by making functions operate uniformly across different types. Many approaches to generic programming have been proposed over the years, most of them for Haskell, but recently also for dependently typed languages such as Agda. Different approaches vary in expressiveness, ease of use, and implementation techniques.\par

Some work has been done in comparing the different approaches informally. However, to our knowledge there have been no attempts to formally prove relations between different approaches. We thus present a formal comparison of generic programming libraries. We show how to formalise different approaches in Agda, including a coinductive representation, and then establish theorems that relate the approaches to each other. We provide constructive proofs of inclusion of one approach in another that can be used to convert between approaches, helping to reduce code duplication across different libraries. Our formalisation also helps in providing a clear picture of the potential of each approach, especially in relating different generic views and their expressiveness.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro and L{\"o}h, Andres},
	booktitle = {Workshop on Mathematically Structured Functional Programming (MSFP)},
	date-added = {2022-02-24 17:28:49 +0800},
	date-modified = {2022-02-24 17:29:13 +0800},
	doi = {10.4204/eptcs.76.6},
	pages = {50--67},
	publisher = {Open Publishing Association},
	series = {Electronic Proceedings in Theoretical Computer Science},
	title = {A Formal Comparison of Approaches to Datatype-Generic Programming},
	volume = {76},
	year = 2012,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxDBAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgAGUAdAAgAGEAbAAgADIAMAAxADIAIAAtACAAQQAgAEYAbwByAG0AYQBsACAAQwBvAG0AcABhAHIAaQBzAG8AbgAgAG8AZgAgAEEAcABwAHIAbwBhAGMAaABlAHMAIAB0AG8AIABEAGEAdABhAHQAeQBwAGUALQBHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBtAGkAbgBnAC4AcABkAGZPEQMUAAAAAAMUAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8UTWFnYWxoYSNGRkZGRkZGRi5wZGYtIEEgRm9ybWFsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAwi86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNYWdhbGhhzINlcyBldCBhbCAyMDEyIC0gQSBGb3JtYWwgQ29tcGFyaXNvbiBvZiBBcHByb2FjaGVzIHRvIERhdGF0eXBlLUdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmAA4AvABdAE0AYQBnAGEAbABoAGEDAwBlAHMAIABlAHQAIABhAGwAIAAyADAAMQAyACAALQAgAEEAIABGAG8AcgBtAGEAbAAgAEMAbwBtAHAAYQByAGkAcwBvAG4AIABvAGYAIABBAHAAcAByAG8AYQBjAGgAZQBzACAAdABvACAARABhAHQAYQB0AHkAcABlAC0ARwBlAG4AZQByAGkAYwAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAwFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTWFnYWxoYcyDZXMgZXQgYWwgMjAxMiAtIEEgRm9ybWFsIENvbXBhcmlzb24gb2YgQXBwcm9hY2hlcyB0byBEYXRhdHlwZS1HZW5lcmljIFByb2dyYW1taW5nLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAGpAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABME=}}

@inproceedings{Rodriguez-generic-libraries,
	abstract = {Datatype-generic programming is defining functions that depend on the structure, or ``shape'', of datatypes. It has been around for more than 10 years, and a lot of progress has been made, in particular in the lazy functional programming language Haskell. There are morethan 10 proposals for generic programming libraries orlanguage extensions for Haskell. To compare and characterise the many generic programming libraries in atyped functional language, we introduce a set of criteria and develop a generic programming benchmark: a set of characteristic examples testing various facets of datatype-generic programming. We have implemented the benchmark for nine existing Haskell generic programming libraries and present the evaluation of the libraries. The comparison is useful for reaching a common standard for generic programming, but also for a programmer who has to choose a particular approach for datatype-generic programming.},
	author = {Rodriguez, Alexey and Jeuring, Johan and Jansson, Patrik and Gerdes, Alex and Kiselyov, Oleg and Oliveira, Bruno C. d. S.},
	booktitle = {International Symposium on Haskell},
	date-added = {2022-02-24 17:18:50 +0800},
	date-modified = {2022-02-24 17:18:50 +0800},
	doi = {10.1145/1411286.1411301},
	pages = {111--122},
	publisher = {ACM},
	title = {Comparing Libraries for Generic Programming in {Haskell}},
	year = 2008,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC1Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1JvZHJpZ3VleiBldCBhbCAyMDA4IC0gQ29tcGFyaW5nIExpYnJhcmllcyBmb3IgR2VuZXJpYyBQcm9ncmFtbWluZyBpbiBIYXNrZWxsLnBkZk8RAuQAAAAAAuQAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9Sb2RyaWd1ZXogZXQgYWwgMjAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgC1LzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OlJvZHJpZ3VleiBldCBhbCAyMDA4IC0gQ29tcGFyaW5nIExpYnJhcmllcyBmb3IgR2VuZXJpYyBQcm9ncmFtbWluZyBpbiBIYXNrZWxsLnBkZgAADgCkAFEAUgBvAGQAcgBpAGcAdQBlAHoAIABlAHQAIABhAGwAIAAyADAAMAA4ACAALQAgAEMAbwBtAHAAYQByAGkAbgBnACAATABpAGIAcgBhAHIAaQBlAHMAIABmAG8AcgAgAEcAZQBuAGUAcgBpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABpAG4AIABIAGEAcwBrAGUAbABsAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCzVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Sb2RyaWd1ZXogZXQgYWwgMjAwOCAtIENvbXBhcmluZyBMaWJyYXJpZXMgZm9yIEdlbmVyaWMgUHJvZ3JhbW1pbmcgaW4gSGFza2VsbC5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkANwAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADxA==}}

@inproceedings{Magalhaes-generic-deriving,
	abstract = {Haskell's \textbf{deriving} mechanism supports the automatic generation of instances for a number of functions. The Haskell 98 Report only specifies how to generate instances for the \textsf{Eq}, \textsf{Ord}, \textsf{Enum}, \textsf{Bounded}, \textsf{Show}, and \textsf{Read} classes. The description of how to generate instances is largely informal. The generation of instances imposes restrictions on the shape of datatypes, depending on the particular class to derive. As a consequence, the portability of instances across different compilers is not guaranteed.\par

We propose a new approach to Haskell's \textbf{deriving} mechanism, which allows users to specify how to derive arbitrary class instances using standard datatype-generic programming techniques. Generic functions, including the methods from six standard Haskell 98 derivable classes, can be specified entirely within Haskell 98 plus multi-parameter type classes, making them lightweight and portable. We can also express \textsf{Functor}, \textsf{Typeable}, and many other derivable classes with our technique. We implemented our \textbf{deriving} mechanism together with many new derivable classes in the Utrecht Haskell Compiler.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro and Dijkstra, Atze and Jeuring, Johan and L{\"o}h, Andres},
	booktitle = {International Symposium on Haskell},
	date-added = {2022-02-24 17:03:54 +0800},
	date-modified = {2022-02-24 17:04:17 +0800},
	doi = {10.1145/1863523.1863529},
	pages = {37--48},
	publisher = {ACM},
	title = {A Generic Deriving Mechanism for {Haskell}},
	year = 2010,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCoAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgAGUAdAAgAGEAbAAgADIAMAAxADAAIAAtACAAQQAgAEcAZQBuAGUAcgBpAGMAIABEAGUAcgBpAHYAaQBuAGcAIABNAGUAYwBoAGEAbgBpAHMAbQAgAGYAbwByACAASABhAHMAawBlAGwAbAAuAHAAZABmTxECsgAAAAACsgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////FE1hZ2FsaGEjRkZGRkZGRkYucGRmLSBBIEdlbmVyaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKkvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWFnYWxoYcyDZXMgZXQgYWwgMjAxMCAtIEEgR2VuZXJpYyBEZXJpdmluZyBNZWNoYW5pc20gZm9yIEhhc2tlbGwucGRmAAAOAIoARABNAGEAZwBhAGwAaABhAwMAZQBzACAAZQB0ACAAYQBsACAAMgAwADEAMAAgAC0AIABBACAARwBlAG4AZQByAGkAYwAgAEQAZQByAGkAdgBpAG4AZwAgAE0AZQBjAGgAYQBuAGkAcwBtACAAZgBvAHIAIABIAGEAcwBrAGUAbABsAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCnVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYWdhbGhhzINlcyBldCBhbCAyMDEwIC0gQSBHZW5lcmljIERlcml2aW5nIE1lY2hhbmlzbSBmb3IgSGFza2VsbC5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAXcAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAELQ==}}

@phdthesis{Loh-thesis,
	abstract = {$\emptyset$},
	author = {L{\"o}h, Andres},
	date-added = {2022-02-24 16:52:45 +0800},
	date-modified = {2022-02-24 16:52:45 +0800},
	school = {Utrecht University},
	title = {Exploring {Generic Haskell}},
	url = {https://www.andres-loeh.de/ExploringGH.pdf},
	year = {2004},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCNAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATABvAwgAaAAgADIAMAAwADQAIAAtACAARQB4AHAAbABvAHIAaQBuAGcAIABHAGUAbgBlAHIAaQBjACAASABhAHMAawBlAGwAbAAuAHAAZABmTxECRAAAAAACRAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////D0xvI0ZGRkZGRkZGLnBkZnJpbmcgR2VuZXJpYyBIYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAI4vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TG/MiGggMjAwNCAtIEV4cGxvcmluZyBHZW5lcmljIEhhc2tlbGwucGRmAA4AVAApAEwAbwMIAGgAIAAyADAAMAA0ACAALQAgAEUAeABwAGwAbwByAGkAbgBnACAARwBlAG4AZQByAGkAYwAgAEgAYQBzAGsAZQBsAGwALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAIxVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0xvzIhoIDIwMDQgLSBFeHBsb3JpbmcgR2VuZXJpYyBIYXNrZWxsLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAFBAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA4k=}}

@book{ML-TT84,
	author = {Per Martin-L{\"o}f},
	date-added = {2022-02-24 14:05:13 +0800},
	date-modified = {2022-02-24 14:05:13 +0800},
	publisher = {Bibliopolis, Napoli},
	read = {1},
	title = {Intuitionistic Type Theory},
	year = {1984},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCVAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAHIAdABpAG4ALQBMAG8DCABmACAAMQA5ADgANAAgAC0AIABJAG4AdAB1AGkAdABpAG8AbgBpAHMAdABpAGMAIABUAHkAcABlACAAVABoAGUAbwByAHkALgBwAGQAZk8RAmQAAAAAAmQAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////xZNYXJ0aW4tTG8jRkZGRkZGRkYucGRmdGlvbmlzdGkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCWLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5Ok1hcnRpbi1Mb8yIZiAxOTg0IC0gSW50dWl0aW9uaXN0aWMgVHlwZSBUaGVvcnkucGRmAA4AZAAxAE0AYQByAHQAaQBuAC0ATABvAwgAZgAgADEAOQA4ADQAIAAtACAASQBuAHQAdQBpAHQAaQBvAG4AaQBzAHQAaQBjACAAVAB5AHAAZQAgAFQAaABlAG8AcgB5AC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCUVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYXJ0aW4tTG/MiGYgMTk4NCAtIEludHVpdGlvbmlzdGljIFR5cGUgVGhlb3J5LnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAFRAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA7k=}}

@inproceedings{ML-TT73,
	abstract = {The theory of types is intended to be a full-scale system for formalizing intuitionistic mathematics as developed. The language of the theory is richer than the languages of traditional intuitionistic systems in permitting proofs to appear as parts of propositions so that the propositions of the theory can express properties of proofs. There are axioms for universes that link the generation of objects and types and play somewhat the same role for the present theory as does the replacement axiom for Zermelo--Fraenkel set theory. The present theory is based on a strongly impredicative axiom that there is a type of all types in symbols. This axiom has to be abandoned, however, after it has been shown to lead to a contraction. This chapter discusses Normalization theorem, which can be strengthened in two ways: it can be made to cover open terms and it can be proved that every reduction sequence starting from an arbitrary term leads to a unique normal term after a finite number of steps. The definition of the notion of convertibility and the proof that an arbitrary term is convertible can no longer be separated because the type symbols and the terms are generated simultaneously.},
	author = {Martin-L{\"o}f, Per},
	booktitle = {Logic Colloquium '73},
	date-added = {2022-02-24 13:34:46 +0800},
	date-modified = {2022-02-24 13:34:46 +0800},
	doi = {10.1016/S0049-237X(08)71945-1},
	pages = {73-118},
	publisher = {Elsevier},
	series = {Studies in Logic and the Foundations of Mathematics},
	title = {An Intuitionistic Theory of Types: Predicative Part},
	volume = {80},
	year = {1975},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCtAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAHIAdABpAG4ALQBMAG8DCABmACAAMQA5ADcANQAgAC0AIABBAG4AIABJAG4AdAB1AGkAdABpAG8AbgBpAHMAdABpAGMAIABUAGgAZQBvAHIAeQAgAG8AZgAgAFQAeQBwAGUAcwAgAFAAcgBlAGQAaQBjAGEAdABpAHYAZQAgAFAAYQByAHQALgBwAGQAZk8RAsQAAAAAAsQAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////xZNYXJ0aW4tTG8jRkZGRkZGRkYucGRmdHVpdGlvbmkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCuLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5Ok1hcnRpbi1Mb8yIZiAxOTc1IC0gQW4gSW50dWl0aW9uaXN0aWMgVGhlb3J5IG9mIFR5cGVzIFByZWRpY2F0aXZlIFBhcnQucGRmAA4AlABJAE0AYQByAHQAaQBuAC0ATABvAwgAZgAgADEAOQA3ADUAIAAtACAAQQBuACAASQBuAHQAdQBpAHQAaQBvAG4AaQBzAHQAaQBjACAAVABoAGUAbwByAHkAIABvAGYAIABUAHkAcABlAHMAIABQAHIAZQBkAGkAYwBhAHQAaQB2AGUAIABQAGEAcgB0AC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCsVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYXJ0aW4tTG/MiGYgMTk3NSAtIEFuIEludHVpdGlvbmlzdGljIFRoZW9yeSBvZiBUeXBlcyBQcmVkaWNhdGl2ZSBQYXJ0LnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAGBAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABEk=}}

@phdthesis{Norell-thesis,
	abstract = {Dependent type theories [ML72] have a long history of being used for theorem proving. One aspect of type theory which makes it very powerful as a proof language is that it mixes deduction with computation. This also makes type theory a good candidate for programming---the strength of the type system allows properties of programs to be stated and established, and the computational properties provide semantics for the programs.\par

This thesis is concerned with bridging the gap between the theoretical presentations of type theory and the requirements on a practical programming language. Although there are many challenging research problems left to solve before we have an industrial scale programming language based on type theory, this thesis takes us a good step along the way.\par

In functional programming languages pattern matching provides a concise notation for defining functions. In dependent type theory, pattern matching becomes even more powerful, in that inspecting the value of a particular term can reveal information about the types and values of other terms. In this thesis we give a type checking algorithm for definitions by pattern matching in type theory, supporting overlapping patterns, and pattern matching on intermediate results using the \emph{with} rule [MM04a].\par

Traditional presentations of type theory suffers from rather verbose notation, cluttering programs and proofs with, for instance, explicit type information. One solution to this problem is to allow terms that can be inferred automatically to be omitted. This is usually implemented by inserting metavariables in place of the omitted terms and using unification to solve these metavariables during type checking. We present a type checking algorithm for a theory with metavariables and prove its soundness independent of whether the metavariables are solved or not.\par

In any programming language it is important to be able to structure large programs into separate units or modules and limit the interaction between these modules. In this thesis we present a simple, but powerful module system for a dependently typed language. The main focus of the module system is to manage the name space of a program, and an important characteristic is a clear separation between the module system and the type checker, making it largely independent of the underlying language.\par

As a side track, not directly related to the use of type theory for programming, we present a connection between type theory and a first-order logic theorem prover. This connection saves the user the burden of proving simple, but tedious first-order theorems by leaving them for the prover. We use a transparent translation to first-order logic which makes the proofs constructed by the theorem prover human readable. The soundness of the connection is established by a general metatheorem.\par

Finally we put our work into practise in the implementation of a programming language, Agda, based on type theory. As an illustrating example we show how to program a simple certified prover for equations in a commutative monoid, which can be used internally in Agda. Much more impressive examples have been done by others, showing that the ideas developed in this thesis are viable in practise.},
	author = {Ulf Norell},
	date-added = {2022-02-24 10:58:54 +0800},
	date-modified = {2022-02-24 10:58:54 +0800},
	school = {Chalmers University of Technology},
	title = {Towards a Practical Programming Language based on Dependent Type Theory},
	url = {http://www.cse.chalmers.se/~ulfn/papers/thesis.html},
	year = {2007},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC9Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L05vcmVsbCAyMDA3IC0gVG93YXJkcyBhIFByYWN0aWNhbCBQcm9ncmFtbWluZyBMYW5ndWFnZSBiYXNlZCBvbiBEZXBlbmRlbnQgVHlwZSBUaGVvcnkucGRmTxEDBAAAAAADBAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H05vcmVsbCAyMDA3IC0gVG93YSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAL0vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6Tm9yZWxsIDIwMDcgLSBUb3dhcmRzIGEgUHJhY3RpY2FsIFByb2dyYW1taW5nIExhbmd1YWdlIGJhc2VkIG9uIERlcGVuZGVudCBUeXBlIFRoZW9yeS5wZGYAAA4AtABZAE4AbwByAGUAbABsACAAMgAwADAANwAgAC0AIABUAG8AdwBhAHIAZABzACAAYQAgAFAAcgBhAGMAdABpAGMAYQBsACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAATABhAG4AZwB1AGEAZwBlACAAYgBhAHMAZQBkACAAbwBuACAARABlAHAAZQBuAGQAZQBuAHQAIABUAHkAcABlACAAVABoAGUAbwByAHkALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASALtVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L05vcmVsbCAyMDA3IC0gVG93YXJkcyBhIFByYWN0aWNhbCBQcm9ncmFtbWluZyBMYW5ndWFnZSBiYXNlZCBvbiBEZXBlbmRlbnQgVHlwZSBUaGVvcnkucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADkAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA+w=}}

@inproceedings{Diehl-InfIR,
	abstract = {The class of Infinitary inductive-recursive (InfIR) types is commonly used to model type theory within itself. While it is common and convenient to provide examples of values within an InfIR model, writing functions that manipulate InfIR types is an underexplored area due to their inherent complexity.\par

Our goal in this work is to push the boundaries of programming with InfIR types by introducing two functions operating over them. The first is a lookup function to extract sub-components from an InfIR type, and the second is an update function to replace sub-components within an InfIR type. We start by considering how to write such functions for concrete examples of InfIR types, and then show how to write generic versions of the functions for any datatype definable in the universe of InfIR types. We actually write two versions of the generic functions, one where the universe is open and another where the universe is closed.},
	author = {Diehl, Larry and Sheard, Tim},
	booktitle = {Workshop on Type-Driven Development (TyDe)},
	date-added = {2022-02-24 10:45:55 +0800},
	date-modified = {2022-02-24 10:45:55 +0800},
	doi = {10.1145/2976022.2976031},
	pages = {1--12},
	publisher = {ACM},
	title = {Generic Lookup and Update for Infinitary Inductive-Recursive Types},
	year = 2016,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC9Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RpZWhsIGV0IGFsIDIwMTYgLSBHZW5lcmljIExvb2t1cCBhbmQgVXBkYXRlIGZvciBJbmZpbml0YXJ5IEluZHVjdGl2ZS1SZWN1cnNpdmUgVHlwZXMucGRmTxEDBAAAAAADBAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0RpZWhsIGV0IGFsIDIwMTYgLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAL0vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6RGllaGwgZXQgYWwgMjAxNiAtIEdlbmVyaWMgTG9va3VwIGFuZCBVcGRhdGUgZm9yIEluZmluaXRhcnkgSW5kdWN0aXZlLVJlY3Vyc2l2ZSBUeXBlcy5wZGYAAA4AtABZAEQAaQBlAGgAbAAgAGUAdAAgAGEAbAAgADIAMAAxADYAIAAtACAARwBlAG4AZQByAGkAYwAgAEwAbwBvAGsAdQBwACAAYQBuAGQAIABVAHAAZABhAHQAZQAgAGYAbwByACAASQBuAGYAaQBuAGkAdABhAHIAeQAgAEkAbgBkAHUAYwB0AGkAdgBlAC0AUgBlAGMAdQByAHMAaQB2AGUAIABUAHkAcABlAHMALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASALtVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RpZWhsIGV0IGFsIDIwMTYgLSBHZW5lcmljIExvb2t1cCBhbmQgVXBkYXRlIGZvciBJbmZpbml0YXJ5IEluZHVjdGl2ZS1SZWN1cnNpdmUgVHlwZXMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADkAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA+w=}}

@book{Brady-Idris-book,
	author = {Brady, Edwin},
	date-added = {2022-02-23 14:56:50 +0800},
	date-modified = {2022-02-23 14:56:50 +0800},
	isbn = {9781617293023},
	publisher = {Manning Publications},
	title = {Type-Driven Development with Idris},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCXLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JyYWR5IDIwMTcgLSBUeXBlLURyaXZlbiBEZXZlbG9wbWVudCB3aXRoIElkcmlzLnBkZk8RAmwAAAAAAmwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9CcmFkeSAyMDE3IC0gVHlwZS0jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkJyYWR5IDIwMTcgLSBUeXBlLURyaXZlbiBEZXZlbG9wbWVudCB3aXRoIElkcmlzLnBkZgAADgBoADMAQgByAGEAZAB5ACAAMgAwADEANwAgAC0AIABUAHkAcABlAC0ARAByAGkAdgBlAG4AIABEAGUAdgBlAGwAbwBwAG0AZQBuAHQAIAB3AGkAdABoACAASQBkAHIAaQBzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9CcmFkeSAyMDE3IC0gVHlwZS1Ecml2ZW4gRGV2ZWxvcG1lbnQgd2l0aCBJZHJpcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL4AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADLg==}}

@book{Stump-Agda-book,
	author = {Stump, Aaron},
	date-added = {2022-02-23 14:54:59 +0800},
	date-modified = {2022-02-23 14:54:59 +0800},
	doi = {10.1145/2841316},
	isbn = {9781970001242},
	publisher = {ACM Books},
	title = {Verified Functional Programming in Agda},
	year = {2016},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCcLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1N0dW1wIDIwMTYgLSBWZXJpZmllZCBGdW5jdGlvbmFsIFByb2dyYW1taW5nIGluIEFnZGEucGRmTxECfgAAAAACfgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1N0dW1wIDIwMTYgLSBWZXJpZiNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6U3R1bXAgMjAxNiAtIFZlcmlmaWVkIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgaW4gQWdkYS5wZGYADgByADgAUwB0AHUAbQBwACAAMgAwADEANgAgAC0AIABWAGUAcgBpAGYAaQBlAGQAIABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAaQBuACAAQQBnAGQAYQAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAmlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvU3R1bXAgMjAxNiAtIFZlcmlmaWVkIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgaW4gQWdkYS5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAwwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANF}}

@inproceedings{Devriese-instance-arguments,
	abstract = {We present instance arguments: an alternative to type classes and related features in the dependently typed, purely functional programming language/proof assistant Agda. They are a new, general type of function arguments, resolved from call-site scope in a type-directed way. The mechanism is inspired by both Scala's implicits and Agda's existing implicit arguments, but differs from both in important ways. Our mechanism is designed and implemented for Agda, but our design choices can be applied to other programming languages as well.\par

Like Scala's implicits, we do not provide a separate structure for type classes and their instances, but instead rely on Agda's standard dependently typed records, so that standard language mechanisms provide features that are missing or expensive in other proposals. Like Scala, we support the equivalent of local instances. Unlike Scala, functions taking our new arguments are first-class citizens and can be abstracted over and manipulated in standard ways. Compared to other proposals, we avoid the pitfall of introducing a separate type-level computational model through the instance search mechanism. All values in scope are automatically candidates for instance resolution. A final novelty of our approach is that existing Agda libraries using records gain the benefits of type classes without any modification.\par

We discuss our implementation in Agda (to be part of Agda 2.2.12) and we use monads as an example to show how it allows existing concepts in the Agda standard library to be used in a similar way as corresponding Haskell code using type classes. We also demonstrate and discuss equivalents and alternatives to some advanced type class-related patterns from the literature and some new patterns specific to our system.},
	author = {Devriese, Dominique and Piessens, Frank},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2022-02-20 20:32:44 +0800},
	date-modified = {2022-02-20 20:32:44 +0800},
	doi = {10.1145/2034773.2034796},
	pages = {143-155},
	publisher = {ACM},
	title = {On the Bright Side of Type Classes: Instance Arguments in {A}gda},
	year = {2011},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC7Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RldnJpZXNlIGV0IGFsIDIwMTEgLSBPbiB0aGUgQnJpZ2h0IFNpZGUgb2YgVHlwZSBDbGFzc2VzIEluc3RhbmNlIEFyZ3VtZW50cyBpbiBBZ2RhLnBkZk8RAvwAAAAAAvwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9EZXZyaWVzZSBldCBhbCAyMDEjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgC7LzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkRldnJpZXNlIGV0IGFsIDIwMTEgLSBPbiB0aGUgQnJpZ2h0IFNpZGUgb2YgVHlwZSBDbGFzc2VzIEluc3RhbmNlIEFyZ3VtZW50cyBpbiBBZ2RhLnBkZgAADgCwAFcARABlAHYAcgBpAGUAcwBlACAAZQB0ACAAYQBsACAAMgAwADEAMQAgAC0AIABPAG4AIAB0AGgAZQAgAEIAcgBpAGcAaAB0ACAAUwBpAGQAZQAgAG8AZgAgAFQAeQBwAGUAIABDAGwAYQBzAHMAZQBzACAASQBuAHMAdABhAG4AYwBlACAAQQByAGcAdQBtAGUAbgB0AHMAIABpAG4AIABBAGcAZABhAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgC5VXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9EZXZyaWVzZSBldCBhbCAyMDExIC0gT24gdGhlIEJyaWdodCBTaWRlIG9mIFR5cGUgQ2xhc3NlcyBJbnN0YW5jZSBBcmd1bWVudHMgaW4gQWdkYS5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAOIAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAD4g==}}

@misc{Kokke-PLFA,
	author = {Kokke, Wen and Wadler, Philip and Siek, Jeremy G.},
	date-added = {2022-02-20 20:13:53 +0800},
	date-modified = {2022-02-20 20:13:53 +0800},
	title = {Programming Language Foundations in {Agda} (Version 20.07)},
	url = {http://plfa.inf.ed.ac.uk/20.07/},
	year = {2020},
	bdsk-url-1 = {https://plfa.github.io}}

@article{Ko-pcOrn,
	abstract = {Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. For example, sequences might be constrained by length or by an ordering on elements, giving rise to different datatypes ``vectors'' and ``sorted lists'' for the same underlying data structure of sequences. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution, in which we axiomatise a family of isomorphisms between datatypes and their more refined versions as datatype refinements, and show that McBride's ornaments can be translated into such refinements. With the ornament-induced refinements, relevant properties of the operations can be separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises a new datatype incorporating those constraints, the operations can be routinely upgraded to work with the synthesised datatype.
},
	author = {Ko, Hsiang-Shang and Gibbons, Jeremy},
	date-added = {2022-02-20 19:34:11 +0800},
	date-modified = {2022-02-20 19:34:11 +0800},
	doi = {10.2201/NiiPi.2013.10.5},
	journal = {Progress in Informatics},
	pages = {65-88},
	read = {1},
	title = {Modularising Inductive Families},
	volume = {10},
	year = {2013},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCXLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZk8RAmwAAAAAAmwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9LbyBldCBhbCAyMDEzIC0gTW8jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OktvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZgAADgBoADMASwBvACAAZQB0ACAAYQBsACAAMgAwADEAMwAgAC0AIABNAG8AZAB1AGwAYQByAGkAcwBpAG4AZwAgAGkAbgBkAHUAYwB0AGkAdgBlACAAZgBhAG0AaQBsAGkAZQBzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL4AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADLg==},
	bdsk-file-2 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCYLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzYS5wZGZPEQJuAAAAAAJuAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fS28gZXQgYWwgMjAxMyAtIE1vI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAmC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpLbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmAA4AagA0AEsAbwAgAGUAdAAgAGEAbAAgADIAMAAxADMAIAAtACAATQBvAGQAdQBsAGEAcgBpAHMAaQBuAGcAIABpAG4AZAB1AGMAdABpAHYAZQAgAGYAYQBtAGkAbABpAGUAcwBhAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCWVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL8AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==}}

@article{Ko-metamorphisms-in-Agda,
	abstract = {In \emph{dependently typed programming}, proofs of basic, structural properties can be embedded implicitly into programs and do not need to be written explicitly. Besides saving the effort of writing separate proofs, a most distinguishing and fascinating aspect of dependently typed programming is that it makes the idea of \emph{interactive type-driven development} much more powerful, where expressive type information becomes useful hints that help the programmer to complete a program. There have not been many attempts at exploiting the full potential of the idea, though. As a departure from the usual properties dealt with in dependently typed programming, and as a demonstration that the idea of interactive type-driven development has more potential to be discovered, we conduct an experiment in `type-driven algorithm design': we develop algorithms from their specifications encoded in sophisticated types, to see how useful the hints provided by a type-aware interactive development environment can be. The algorithmic problem we choose is \emph{metamorphisms}, whose definitional behaviour is consuming a data structure to compute an intermediate value and then producing a codata structure from that value, but there are other ways to compute metamorphisms. We develop Gibbons's streaming algorithm and Nakano's jigsaw model in the interactive development environment provided by the dependently typed language Agda, turning intuitive ideas about these algorithms into formal conditions and programs that are correct by construction.},
	author = {Ko, Hsiang-Shang},
	date-added = {2022-02-20 19:01:47 +0800},
	date-modified = {2022-02-20 19:01:47 +0800},
	doi = {10.22152/programming-journal.org/2021/5/7},
	journal = {The Art, Science, and Engineering of Programming},
	number = {2},
	pages = {7:1-34},
	title = {Programming Metamorphic Algorithms: An Experiment in Type-driven Algorithm Design},
	volume = {5},
	year = {2021},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxDCLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIDIwMjEgLSBQcm9ncmFtbWluZyBNZXRhbW9ycGhpYyBBbGdvcml0aG1zIEFuIEV4cGVyaW1lbnQgaW4gVHlwZS1kcml2ZW4gQWxnb3JpdGhtIERlc2lnbi5wZGZPEQMWAAAAAAMWAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fS28gMjAyMSAtIFByb2dyYW1tI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAwi86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpLbyAyMDIxIC0gUHJvZ3JhbW1pbmcgTWV0YW1vcnBoaWMgQWxnb3JpdGhtcyBBbiBFeHBlcmltZW50IGluIFR5cGUtZHJpdmVuIEFsZ29yaXRobSBEZXNpZ24ucGRmAA4AvgBeAEsAbwAgADIAMAAyADEAIAAtACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAATQBlAHQAYQBtAG8AcgBwAGgAaQBjACAAQQBsAGcAbwByAGkAdABoAG0AcwAgAEEAbgAgAEUAeABwAGUAcgBpAG0AZQBuAHQAIABpAG4AIABUAHkAcABlAC0AZAByAGkAdgBlAG4AIABBAGwAZwBvAHIAaQB0AGgAbQAgAEQAZQBzAGkAZwBuAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgDAVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyAyMDIxIC0gUHJvZ3JhbW1pbmcgTWV0YW1vcnBoaWMgQWxnb3JpdGhtcyBBbiBFeHBlcmltZW50IGluIFR5cGUtZHJpdmVuIEFsZ29yaXRobSBEZXNpZ24ucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAOkAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEAw==}}

@article{Alon-code2vec,
	abstract = {We present a neural model for representing snippets of code as continuous distributed vectors (``code embeddings''). The main idea is to represent a code snippet as a single fixed-length \emph{code vector}, which can be used to predict semantic properties of the snippet. To this end, code is first decomposed to a collection of paths in its abstract syntax tree. Then, the network learns the atomic representation of each path while \emph{simultaneously} learning how to aggregate a set of them.\par

We demonstrate the effectiveness of our approach by using it to predict a method's name from the vector representation of its body. We evaluate our approach by training a model on a dataset of 12M methods. We show that code vectors trained on this dataset can predict method names from files that were unobserved during training. Furthermore, we show that our model learns useful method name vectors that capture semantic similarities, combinations, and analogies.\par

A comparison of our approach to previous techniques over the same dataset shows an improvement of more than 75\%, making it the first to successfully predict method names based on a large, cross-project corpus. Our trained model, visualizations and vector similarities are available as an interactive online demo at http://code2vec.org. The code, data and trained models are available at https://github.com/tech-srl/code2vec.},
	author = {Alon, Uri and Zilberstein, Meital and Levy, Omer and Yahav, Eran},
	date-added = {2022-02-18 17:27:34 +0800},
	date-modified = {2022-02-18 17:27:34 +0800},
	doi = {10.1145/3290353},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {40:1--29},
	title = {{code2vec}: Learning Distributed Representations of Code},
	volume = {3},
	year = 2019,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCvLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Fsb24gZXQgYWwgMjAxOSAtIGNvZGUydmVjIExlYXJuaW5nIERpc3RyaWJ1dGVkIFJlcHJlc2VudGF0aW9ucyBvZiBDb2RlLnBkZk8RAswAAAAAAswAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9BbG9uIGV0IGFsIDIwMTkgLSAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCvLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkFsb24gZXQgYWwgMjAxOSAtIGNvZGUydmVjIExlYXJuaW5nIERpc3RyaWJ1dGVkIFJlcHJlc2VudGF0aW9ucyBvZiBDb2RlLnBkZgAADgCYAEsAQQBsAG8AbgAgAGUAdAAgAGEAbAAgADIAMAAxADkAIAAtACAAYwBvAGQAZQAyAHYAZQBjACAATABlAGEAcgBuAGkAbgBnACAARABpAHMAdAByAGkAYgB1AHQAZQBkACAAUgBlAHAAcgBlAHMAZQBuAHQAYQB0AGkAbwBuAHMAIABvAGYAIABDAG8AZABlAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCtVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9BbG9uIGV0IGFsIDIwMTkgLSBjb2RlMnZlYyBMZWFybmluZyBEaXN0cmlidXRlZCBSZXByZXNlbnRhdGlvbnMgb2YgQ29kZS5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkANYAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADpg==}}

@article{Dybjer-indexed-induction-recursion,
	author = {Dybjer, Peter and Setzer, Anton},
	date-added = {2022-02-17 10:19:28 +0800},
	date-modified = {2022-02-17 14:56:06 +0800},
	doi = {10.1016/j.jlap.2005.07.001},
	journal = {Journal of Logic and Algebraic Programming},
	number = {1},
	pages = {1-49},
	title = {Indexed Induction-Recursion},
	volume = {66},
	year = {2006},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCXLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0R5YmplciBldCBhbCAyMDA2IC0gSW5kZXhlZCBpbmR1Y3Rpb24tcmVjdXJzaW9uLnBkZk8RAmwAAAAAAmwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9EeWJqZXIgZXQgYWwgMjAwNiAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkR5YmplciBldCBhbCAyMDA2IC0gSW5kZXhlZCBpbmR1Y3Rpb24tcmVjdXJzaW9uLnBkZgAADgBoADMARAB5AGIAagBlAHIAIABlAHQAIABhAGwAIAAyADAAMAA2ACAALQAgAEkAbgBkAGUAeABlAGQAIABpAG4AZAB1AGMAdABpAG8AbgAtAHIAZQBjAHUAcgBzAGkAbwBuAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9EeWJqZXIgZXQgYWwgMjAwNiAtIEluZGV4ZWQgaW5kdWN0aW9uLXJlY3Vyc2lvbi5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL4AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADLg==}}

@article{Benke-generic-universes,
	abstract = {We show how to write generic programs and proofs in Martin-L{\"o}f type theory. To this end we consider several extensions of Martin-L{\"o}f's logical framework for dependent types. Each extension has a universe of codes (signatures) for inductively defined sets with generic formation, introduction, elimination, and equality rules. These extensions are modeled on Dybjer and Setzer's finitely axiomatized theories of inductive-recursive definitions, which also have universes of codes for sets, and generic formation, introduction, elimination, and equality rules. Here we consider several smaller universes of interest for generic programming and universal algebra. We formalize one-sorted and many-sorted term algebras, as well as iterated, generalized, parameterized, and indexed inductive definitions. We also show how to extend the techniques of generic programming to these universes. Furthermore, we give generic proofs of reflexivity and substitutivity of a generic equality test: Most of the definitions in the paper have been implemented using the proof assistant Alfa for dependent type theory.},
	author = {Benke, Marcin and Dybjer, Peter and Jansson, Patrik},
	date-added = {2022-02-16 22:35:57 +0800},
	date-modified = {2022-02-16 22:35:57 +0800},
	journal = {Nordic Journal of Computing},
	number = {4},
	pages = {265--289},
	title = {Universes for Generic Programs and Proofs in Dependent Type Theory},
	url = {https://www.mimuw.edu.pl/~ben/Papers/universes.pdf},
	volume = {10},
	year = {2003},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC9Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JlbmtlIGV0IGFsIDIwMDMgLSBVbml2ZXJzZXMgZm9yIEdlbmVyaWMgUHJvZ3JhbXMgYW5kIFByb29mcyBpbiBEZXBlbmRlbnQgVHlwZSBUaGVvcnkucGRmTxEDBAAAAAADBAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0JlbmtlIGV0IGFsIDIwMDMgLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAL0vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QmVua2UgZXQgYWwgMjAwMyAtIFVuaXZlcnNlcyBmb3IgR2VuZXJpYyBQcm9ncmFtcyBhbmQgUHJvb2ZzIGluIERlcGVuZGVudCBUeXBlIFRoZW9yeS5wZGYAAA4AtABZAEIAZQBuAGsAZQAgAGUAdAAgAGEAbAAgADIAMAAwADMAIAAtACAAVQBuAGkAdgBlAHIAcwBlAHMAIABmAG8AcgAgAEcAZQBuAGUAcgBpAGMAIABQAHIAbwBnAHIAYQBtAHMAIABhAG4AZAAgAFAAcgBvAG8AZgBzACAAaQBuACAARABlAHAAZQBuAGQAZQBuAHQAIABUAHkAcABlACAAVABoAGUAbwByAHkALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASALtVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JlbmtlIGV0IGFsIDIwMDMgLSBVbml2ZXJzZXMgZm9yIEdlbmVyaWMgUHJvZ3JhbXMgYW5kIFByb29mcyBpbiBEZXBlbmRlbnQgVHlwZSBUaGVvcnkucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADkAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA+w=}}

@inproceedings{McDonell-Ghostbuster,
	abstract = {Generalized Algebraic Dataypes, or simply GADTs, can encode non-trivial properties in the types of the constructors. Once such properties are encoded in a datatype, however, \emph{all} code manipulating that datatype must provide proof that it maintains these properties in order to typecheck. In this paper, we take a step towards \emph{gradualizing} these obligations. We introduce a tool, Ghostbuster, that produces simplified versions of GADTs which elide selected type parameters, thereby weakening the guarantees of the simplified datatype in exchange for reducing the obligations necessary to manipulate it. Like \emph{ornaments}, these simplified datatypes preserve the recursive structure of the original, but unlike ornaments we focus on information-preserving bidirectional transformations. Ghostbuster generates type-safe conversion functions between the original and simplified datatypes, which we prove are the identity function when composed. We evaluate a prototype tool for Haskell against thousands of GADTs found on the Hackage package database, generating simpler Haskell'98 datatypes and round-trip conversion functions between the two.},
	author = {McDonell, Trevor L. and Zakian, Timothy A. K. and Cimini, Matteo and Newton, Ryan R.},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2022-02-16 11:10:54 +0800},
	date-modified = {2022-02-16 11:10:54 +0800},
	doi = {10.1145/3022670.2951914},
	pages = {338-350},
	publisher = {ACM},
	title = {{Ghostbuster}: A Tool for Simplifying and Converting {GADTs}},
	year = {2016},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC1Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jRG9uZWxsIGV0IGFsIDIwMTYgLSBHaG9zdGJ1c3RlciBBIFRvb2wgZm9yIFNpbXBsaWZ5aW5nIGFuZCBDb252ZXJ0aW5nIEdBRFRzLnBkZk8RAuQAAAAAAuQAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9NY0RvbmVsbCBldCBhbCAyMDEjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgC1LzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5Ok1jRG9uZWxsIGV0IGFsIDIwMTYgLSBHaG9zdGJ1c3RlciBBIFRvb2wgZm9yIFNpbXBsaWZ5aW5nIGFuZCBDb252ZXJ0aW5nIEdBRFRzLnBkZgAADgCkAFEATQBjAEQAbwBuAGUAbABsACAAZQB0ACAAYQBsACAAMgAwADEANgAgAC0AIABHAGgAbwBzAHQAYgB1AHMAdABlAHIAIABBACAAVABvAG8AbAAgAGYAbwByACAAUwBpAG0AcABsAGkAZgB5AGkAbgBnACAAYQBuAGQAIABDAG8AbgB2AGUAcgB0AGkAbgBnACAARwBBAEQAVABzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCzVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NY0RvbmVsbCBldCBhbCAyMDE2IC0gR2hvc3RidXN0ZXIgQSBUb29sIGZvciBTaW1wbGlmeWluZyBhbmQgQ29udmVydGluZyBHQURUcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkANwAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADxA==}}

@inproceedings{Stevens-multiary-BX,
	abstract = {The model-driven development of systems involves multiple models, metamodels and transformations, and relationships between them. A bidirectional transformation (bx) is usually defined as a means of maintaining consistency between "two (or more)" models. This includes cases where one model may be generated from one or more others, as well as more complex ("symmetric") cases where models record partially overlapping information. In recent years binary bx, those relating two models, have been extensively studied. Multiary1 bx, those relating more than two models, have received less attention. In this paper we consider how a multiary consistency relation may be defined in terms of binary consistency relations, and how consistency restoration may be carried out on a network of models and relationships between them. We relate this to megamodelling and discuss further research that is needed.},
	author = {Stevens, Perdita},
	booktitle = {International Conference on Model Driven Engineering Languages and Systems (MODELS)},
	date-added = {2022-02-14 15:14:29 +0800},
	date-modified = {2022-02-26 10:46:20 +0800},
	doi = {10.1109/MODELS.2017.8},
	pages = {1-11},
	publisher = {IEEE},
	title = {Bidirectional Transformations in the Large},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxChLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1N0ZXZlbnMgMjAxNyAtIEJpZGlyZWN0aW9uYWwgVHJhbnNmb3JtYXRpb25zIGluIHRoZSBMYXJnZS5wZGZPEQKUAAAAAAKUAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fU3RldmVucyAyMDE3IC0gQmlkI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAoS86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpTdGV2ZW5zIDIwMTcgLSBCaWRpcmVjdGlvbmFsIFRyYW5zZm9ybWF0aW9ucyBpbiB0aGUgTGFyZ2UucGRmAAAOAHwAPQBTAHQAZQB2AGUAbgBzACAAMgAwADEANwAgAC0AIABCAGkAZABpAHIAZQBjAHQAaQBvAG4AYQBsACAAVAByAGEAbgBzAGYAbwByAG0AYQB0AGkAbwBuAHMAIABpAG4AIAB0AGgAZQAgAEwAYQByAGcAZQAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAn1VzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvU3RldmVucyAyMDE3IC0gQmlkaXJlY3Rpb25hbCBUcmFuc2Zvcm1hdGlvbnMgaW4gdGhlIExhcmdlLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQAyAAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANg}}

@inproceedings{Pickering-pattern-synonyms,
	abstract = {Pattern matching has proven to be a convenient, expressive way of inspecting data. Yet this language feature, in its traditional form, is limited: patterns must be data constructors of concrete data types. No computation or abstraction is allowed. The data type in question must be concrete, with no ability to enforce any invariants. Any change in this data type requires all clients to update their code.\par

This paper introduces \emph{pattern synonyms}, which allow programmers to abstract over patterns, painting over all the shortcomings listed above. Pattern synonyms are assigned types, enabling a compiler to check the validity of a synonym independent of its definition. These types are intricate; detailing how to assign a type to a pattern synonym is a key contribution of this work. We have implemented pattern synonyms in the Glasgow Haskell Compiler, where they have enjoyed immediate popularity, but we believe this feature could easily be exported to other languages that support pattern matching.},
	author = {Pickering, Matthew and {\'E}rdi, Gergo Gerg{\H o} and Peyton Jones, Simon and Eisenberg, Richard A.},
	booktitle = {International Symposium on Haskell},
	date-added = {2022-02-09 13:31:02 +0800},
	date-modified = {2022-02-09 13:31:02 +0800},
	doi = {10.1145/2976002.2976013},
	pages = {80--91},
	publisher = {ACM},
	title = {Pattern Synonyms},
	year = 2016,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCPLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1BpY2tlcmluZyBldCBhbCAyMDE2IC0gUGF0dGVybiBTeW5vbnltcy5wZGZPEQJMAAAAAAJMAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fUGlja2VyaW5nIGV0IGFsIDIwI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAjy86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpQaWNrZXJpbmcgZXQgYWwgMjAxNiAtIFBhdHRlcm4gU3lub255bXMucGRmAAAOAFgAKwBQAGkAYwBrAGUAcgBpAG4AZwAgAGUAdAAgAGEAbAAgADIAMAAxADYAIAAtACAAUABhAHQAdABlAHIAbgAgAFMAeQBuAG8AbgB5AG0AcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAjVVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvUGlja2VyaW5nIGV0IGFsIDIwMTYgLSBQYXR0ZXJuIFN5bm9ueW1zLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQAtgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAMG}}

@phdthesis{Morris-thesis,
	abstract = {Programming languages with an expressive language for defining data types often suffer from an excess in boiler-plate code and lack of re-usable, extendible libraries. Dependently typed programming languages are especially prone to such problems. With dependent types one can specify any number of relationships between data and types, to better specify the correct behaviour of programs. Thus one might begin with a single list type and extend it to lists on a known length, or ordered lists, or
ordered lists of a known length. The possibilities are endless. Each of these `list-like' structures will support some kind of functorial map, yet each new variant must come with a new definition of $\mathit{map}$ that looks rather like all the others. Epigram is a dependently typed functional programming language which suffers from just this proliferation of types.\par

This thesis suggests a solution to the data type proliferation problem for Epigram, combining universes and generic programming. Universes are a means to abstract over specific classes of types. Generic or polytypic programming is a technique by which functions are specialised on the structure of the type of their arguments. By using universes to abstract over the syntax of a class of data types, generic programming can be incorporated into Epigram without extending the language. Thus, functions
like $\mathit{map}$ can be defined once, not just for list like structures but a whole range of types.\par

The story begins with a class of simple types which are given a purely syntactic treatment and a second, semantic, interpretation, based on the theory of containers. The syntactic and semantic views permit complimentary access to generic programming with these types. It is then shown that the generalisation of these techniques to a rich class of types, is not a difficult jump. The system that results is strong enough to allow generic programming for any data type that can be defined in Epigram.},
	author = {Peter Morris},
	date-added = {2022-02-09 11:33:00 +0800},
	date-modified = {2022-02-09 11:33:00 +0800},
	read = {1},
	school = {University of Nottingham},
	title = {Constructing Universes for Generic Programming},
	year = {2007},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCkLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01vcnJpcyAyMDA3IC0gQ29uc3RydWN0aW5nIFVuaXZlcnNlcyBmb3IgR2VuZXJpYyBQcm9ncmFtbWluZy5wZGZPEQKeAAAAAAKeAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fTW9ycmlzIDIwMDcgLSBDb25zI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIApC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNb3JyaXMgMjAwNyAtIENvbnN0cnVjdGluZyBVbml2ZXJzZXMgZm9yIEdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmAA4AggBAAE0AbwByAHIAaQBzACAAMgAwADAANwAgAC0AIABDAG8AbgBzAHQAcgB1AGMAdABpAG4AZwAgAFUAbgBpAHYAZQByAHMAZQBzACAAZgBvAHIAIABHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBtAGkAbgBnAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCiVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Nb3JyaXMgMjAwNyAtIENvbnN0cnVjdGluZyBVbml2ZXJzZXMgZm9yIEdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAMsAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADbQ==}}

@book{Bird-AoP,
	author = {Bird, Richard and de Moor, Oege},
	date-added = {2022-02-08 16:02:46 +0800},
	date-modified = {2022-02-08 16:02:46 +0800},
	isbn = {9780135072455},
	publisher = {Prentice-Hall},
	read = {1},
	title = {Algebra of Programming},
	year = {1997},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCQLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JpcmQgZXQgYWwgMTk5NyAtIEFsZ2VicmEgb2YgUHJvZ3JhbW1pbmcucGRmTxECTgAAAAACTgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0JpcmQgZXQgYWwgMTk5NyAtICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAUERGIENBUk8ABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJAvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QmlyZCBldCBhbCAxOTk3IC0gQWxnZWJyYSBvZiBQcm9ncmFtbWluZy5wZGYADgBaACwAQgBpAHIAZAAgAGUAdAAgAGEAbAAgADEAOQA5ADcAIAAtACAAQQBsAGcAZQBiAHIAYQAgAG8AZgAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAjlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQmlyZCBldCBhbCAxOTk3IC0gQWxnZWJyYSBvZiBQcm9ncmFtbWluZy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAtwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAMJ}}

@inproceedings{Magalhaes-optimising-generics,
	abstract = {Datatype-generic programming increases program reliability by reducing code duplication and enhancing reusability and modularity. Several generic programming libraries for Haskell have been developed in the past few years. These libraries have been compared in detail with respect to expressiveness, extensibility, typing issues, etc., but performance comparisons have been brief, limited, and preliminary. It is widely believed that generic programs run slower than hand-written code. In this paper we present an extensive benchmark suite for generic functions and analyze the potential for automatic code optimization at compilation time. Our benchmark confirms that generic programs, when compiled with the standard optimization flags of the Glasgow Haskell Compiler (GHC), are substantially slower than their hand-written counterparts. However, we also find that more advanced optimization capabilities of GHC can be used to further optimize generic functions, sometimes achieving the same efficiency as hand-written code.},
	author = {Magalh{\~a}es, Jos{\'e} Pedro and Holdermans, Stefan and Jeuring, Johan and L{\"o}h, Andres},
	booktitle = {Workshop on Partial Evaluation and Program Manipulation (PEPM)},
	date-added = {2022-02-04 15:34:20 +0800},
	date-modified = {2022-02-26 10:40:49 +0800},
	doi = {10.1145/1706356.1706366},
	pages = {33-42},
	publisher = {ACM},
	title = {Optimizing Generics Is Easy!\NoPeriod},
	year = 2010,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCcAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ATQBhAGcAYQBsAGgAYQMDAGUAcwAgAGUAdAAgAGEAbAAgADIAMAAxADAAIAAtACAATwBwAHQAaQBtAGkAegBpAG4AZwAgAEcAZQBuAGUAcgBpAGMAcwAgAEkAcwAgAEUAYQBzAHkAIQAuAHAAZABmTxECggAAAAACggACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////FE1hZ2FsaGEjRkZGRkZGRkYucGRmLSBPcHRpbWl6aQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJ0vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWFnYWxoYcyDZXMgZXQgYWwgMjAxMCAtIE9wdGltaXppbmcgR2VuZXJpY3MgSXMgRWFzeSEucGRmAAAOAHIAOABNAGEAZwBhAGwAaABhAwMAZQBzACAAZQB0ACAAYQBsACAAMgAwADEAMAAgAC0AIABPAHAAdABpAG0AaQB6AGkAbgBnACAARwBlAG4AZQByAGkAYwBzACAASQBzACAARQBhAHMAeQAhAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCbVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9NYWdhbGhhzINlcyBldCBhbCAyMDEwIC0gT3B0aW1pemluZyBHZW5lcmljcyBJcyBFYXN5IS5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAV8AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAD5Q==}}

@article{Cockx-pattern-matching-without-K,
	abstract = {Dependent pattern matching is an intuitive way to write programs and proofs in dependently typed languages. It is reminiscent of both pattern matching in functional languages and case analysis in on-paper mathematics. However, in general, it is incompatible with new type theories such as homotopy type theory (HoTT). As a consequence, proofs in such theories are typically harder to write and to understand. The source of this incompatibility is the reliance of dependent pattern matching on the so-called K axiom -- also known as the uniqueness of identity proofs -- which is inadmissible in HoTT. In this paper, we propose a new criterion for dependent pattern matching without K, and prove it correct by a translation to eliminators in the style of Goguen et al . (2006 Algebra, Meaning, and Computation ). Our criterion is both less restrictive than existing proposals, and solves a previously undetected problem in the old criterion offered by Agda. It has been implemented in Agda and is the first to be supported by a formal proof. Thus, it brings the benefits of dependent pattern matching to contexts where we cannot assume K, such as HoTT.},
	author = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
	date-modified = {2022-02-13 17:21:25 +0800},
	doi = {10.1017/S0956796816000174},
	journal = {Journal of Functional Programming},
	pages = {e16:1--40},
	title = {Eliminating Dependent Pattern Matching without {K}},
	volume = {26},
	year = {2016},
	bdsk-url-1 = {https://www.cambridge.org/core/product/identifier/S0956796816000174/type/journal%7B%5C_%7Darticle},
	bdsk-url-2 = {https://doi.org/10.1017/S0956796816000174}}

@article{de-Bruijn-telescopes,
	abstract = {The paper develops notation for strings of abstractors in typed lambda calculus, and shows how to treat them more or less as single abstractors.},
	author = {de Bruijn, N. G.},
	date-added = {2022-02-01 17:23:55 +0800},
	date-modified = {2022-02-01 17:23:55 +0800},
	doi = {10.1016/0890-5401(91)90066-b},
	journal = {Information and Computation},
	number = {2},
	pages = {189--204},
	title = {Telescopic Mappings in Typed Lambda Calculus},
	volume = {91},
	year = 1991,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCiLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JydWlqbiAxOTkxIC0gVGVsZXNjb3BpYyBNYXBwaW5ncyBpbiBUeXBlZCBMYW1iZGEgQ2FsY3VsdXMucGRmTxEClgAAAAAClgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0JydWlqbiAxOTkxIC0gVGVsZSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKIvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QnJ1aWpuIDE5OTEgLSBUZWxlc2NvcGljIE1hcHBpbmdzIGluIFR5cGVkIExhbWJkYSBDYWxjdWx1cy5wZGYADgB+AD4AQgByAHUAaQBqAG4AIAAxADkAOQAxACAALQAgAFQAZQBsAGUAcwBjAG8AcABpAGMAIABNAGEAcABwAGkAbgBnAHMAIABpAG4AIABUAHkAcABlAGQAIABMAGEAbQBiAGQAYQAgAEMAYQBsAGMAdQBsAHUAcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAoFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQnJ1aWpuIDE5OTEgLSBUZWxlc2NvcGljIE1hcHBpbmdzIGluIFR5cGVkIExhbWJkYSBDYWxjdWx1cy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAyQAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANj}}

@inproceedings{Chapman-levitation,
	abstract = {We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a \emph{universe}. Each inductive datatype arises by interpreting its \emph{description}---a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.},
	author = {Chapman, James and Dagand, Pierre-{\'E}variste and McBride, Conor and Morris, Peter},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2022-01-29 23:25:41 +0800},
	date-modified = {2022-01-29 23:25:41 +0800},
	doi = {10.1145/1863543.1863547},
	pages = {3-14},
	publisher = {ACM},
	read = {1},
	title = {The Gentle Art of Levitation},
	year = {2010},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCZLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmTxECdAAAAAACdAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0NoYXBtYW4gZXQgYWwgMjAxMCNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJkvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6Q2hhcG1hbiBldCBhbCAyMDEwIC0gVGhlIEdlbnRsZSBBcnQgb2YgTGV2aXRhdGlvbi5wZGYAAA4AbAA1AEMAaABhAHAAbQBhAG4AIABlAHQAIABhAGwAIAAyADAAMQAwACAALQAgAFQAaABlACAARwBlAG4AdABsAGUAIABBAHIAdAAgAG8AZgAgAEwAZQB2AGkAdABhAHQAaQBvAG4ALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJdVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADAAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAzg=}}

@article{Xie-Typed-Template-Haskell,
	abstract = {Multi-stage programming using typed code quotation is an established technique for writing optimizing code generators with strong type-safety guarantees. Unfortunately, quotation in Haskell interacts poorly with type classes, making it difficult to write robust multi-stage programs.\par

We study this unsound interaction and propose a resolution, \emph{staged type class constraints}, which we formalize in a source calculus $\lambda^{[\![{\Rightarrow}]\!]}$ that elaborates into an explicit core calculus $F^{[\![]\!]}$. We show type soundness of both calculi, establishing that well-typed, well-staged source programs always elaborate to well-typed, well-staged core programs, and prove beta and eta rules for code quotations.\par

Our design allows programmers to incorporate type classes into multi-stage programs with confidence. Although motivated by Haskell, it is also suitable as a foundation for other languages that support both overloading and quotation.},
	author = {Xie, Ningning and Pickering, Matthew and L{\"o}h, Andres and Wu, Nicolas and Yallop, Jeremy and Wang, Meng},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3498723},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {61:1--30},
	title = {Staging with Class: A Specification for {Typed Template Haskell}},
	volume = {6},
	year = 2022,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC2Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1hpZSBldCBhbCAyMDIyIC0gU3RhZ2luZyB3aXRoIENsYXNzIEEgU3BlY2lmaWNhdGlvbiBmb3IgVHlwZWQgVGVtcGxhdGUgSGFza2VsbC5wZGZPEQLmAAAAAALmAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fWGllIGV0IGFsIDIwMjIgLSBTI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAti86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpYaWUgZXQgYWwgMjAyMiAtIFN0YWdpbmcgd2l0aCBDbGFzcyBBIFNwZWNpZmljYXRpb24gZm9yIFR5cGVkIFRlbXBsYXRlIEhhc2tlbGwucGRmAA4ApgBSAFgAaQBlACAAZQB0ACAAYQBsACAAMgAwADIAMgAgAC0AIABTAHQAYQBnAGkAbgBnACAAdwBpAHQAaAAgAEMAbABhAHMAcwAgAEEAIABTAHAAZQBjAGkAZgBpAGMAYQB0AGkAbwBuACAAZgBvAHIAIABUAHkAcABlAGQAIABUAGUAbQBwAGwAYQB0AGUAIABIAGEAcwBrAGUAbABsAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgC0VXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9YaWUgZXQgYWwgMjAyMiAtIFN0YWdpbmcgd2l0aCBDbGFzcyBBIFNwZWNpZmljYXRpb24gZm9yIFR5cGVkIFRlbXBsYXRlIEhhc2tlbGwucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAN0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADxw==}}

@inproceedings{Kovacs-universe-hierarchies,
	abstract = {In type theories, universe hierarchies are commonly used to increase the expressive power of the theory while avoiding inconsistencies arising from size issues. There are numerous ways to specify universe hierarchies, and theories may differ in details of cumulativity, choice of universe levels, specification of type formers and eliminators, and available internal operations on levels. In the current work, we aim to provide a framework which covers a large part of the design space. First, we develop syntax and semantics for cumulative universe hierarchies, where levels may come from any set equipped with a transitive well-founded ordering. In the semantics, we show that induction-recursion can be used to model transfinite hierarchies, and also support lifting operations on type codes which strictly preserve type formers. Then, we consider a setup where universe levels are first-class types and subject to arbitrary internal reasoning. This generalizes the bounded polymorphism features of Coq and at the same time the internal level computations in Agda.},
	author = {Kov{\'a}cs, Andr{\'a}s},
	booktitle = {Conference on Computer Science Logic (CSL)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.4230/LIPIcs.CSL.2022.28},
	pages = {28:1--17},
	publisher = {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
	series = {Leibniz International Proceedings in Informatics (LIPIcs)},
	title = {Generalized Universe Hierarchies and First-Class Universe Levels},
	volume = {216},
	year = {2022},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxC3AC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ASwBvAHYAYQMBAGMAcwAgADIAMAAyADIAIAAtACAARwBlAG4AZQByAGEAbABpAHoAZQBkACAAVQBuAGkAdgBlAHIAcwBlACAASABpAGUAcgBhAHIAYwBoAGkAZQBzACAAYQBuAGQAIABGAGkAcgBzAHQALQBDAGwAYQBzAHMAIABVAG4AaQB2AGUAcgBzAGUAIABMAGUAdgBlAGwAcwAuAHAAZABmTxEC7AAAAAAC7AACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////EUtvdmEjRkZGRkZGRkYucGRmcmFsaXplZCBVbml2ZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACALgvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6S292YcyBY3MgMjAyMiAtIEdlbmVyYWxpemVkIFVuaXZlcnNlIEhpZXJhcmNoaWVzIGFuZCBGaXJzdC1DbGFzcyBVbml2ZXJzZSBMZXZlbHMucGRmAA4AqABTAEsAbwB2AGEDAQBjAHMAIAAyADAAMgAyACAALQAgAEcAZQBuAGUAcgBhAGwAaQB6AGUAZAAgAFUAbgBpAHYAZQByAHMAZQAgAEgAaQBlAHIAYQByAGMAaABpAGUAcwAgAGEAbgBkACAARgBpAHIAcwB0AC0AQwBsAGEAcwBzACAAVQBuAGkAdgBlAHIAcwBlACAATABlAHYAZQBsAHMALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASALZVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvdmHMgWNzIDIwMjIgLSBHZW5lcmFsaXplZCBVbml2ZXJzZSBIaWVyYXJjaGllcyBhbmQgRmlyc3QtQ2xhc3MgVW5pdmVyc2UgTGV2ZWxzLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAGVAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABIU=}}

@article{Jang-Moebius,
	abstract = {We describe the foundation of the metaprogramming language, M{\oe}bius, which supports the generation of polymorphic code and, more importantly, the analysis of polymorphic code via pattern matching.\par

M{\oe}bius has two main ingredients: 1) we exploit contextual modal types to describe open code together with the context in which it is meaningful. In M{\oe}bius, open code can depend on type and term variables (level 0) whose values are supplied at a later stage, as well as code variables (level 1) that stand for code templates supplied at a later stage. This leads to a multi-level modal lambda-calculus that supports System-F style polymorphism and forms the basis for polymorphic code generation. 2) we extend the multi-level modal lambda-calculus to support pattern matching on code. As pattern matching on polymorphic code may refine polymorphic type variables, we extend our type-theoretic foundation to generate and track typing constraints that arise. We also give an operational semantics and prove type preservation.\par

Our multi-level modal foundation for M{\oe}bius provides the appropriate abstractions for both generating and pattern matching on open code without committing to a concrete representation of variable binding and contexts. Hence, our work is a step towards building a general type-theoretic foundation for multi-staged metaprogramming that, on the one hand, enforces strong type guarantees and, on the other hand, makes it easy to generate and manipulate code. This will allow us to exploit the full potential of metaprogramming without sacrificing the reliability of and trust in the code we are producing and running.},
	author = {Jang, Junyoung and G{\'e}lineau, Samuel and Monnier, Stefan and Pientka, Brigitte},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3498700},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {39:1--27},
	title = {{M{\oe}bius}: Metaprogramming Using Contextual Types: The Stage where {System F} Can Pattern Match on Itself},
	volume = {6},
	year = 2022,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxDcAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8ASgBhAG4AZwAgAGUAdAAgAGEAbAAgADIAMAAyADIAIAAtACAATQFTAGIAaQB1AHMAIABNAGUAdABhAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAFUAcwBpAG4AZwAgAEMAbwBuAHQAZQB4AHQAdQBhAGwAIABUAHkAcABlAHMAIABUAGgAZQAgAFMAdABhAGcAZQAgAHcAaABlAHIAZQAgAFMAeQBzAHQAZQBtACAARgAgAEMAYQBuACAAUABhAHQAdABlAHIAbgAgAE0AYQB0AGMAaAAgAG8AbgAgAEkAdABzAGUAbABmAC4AcABkAGZPEQOCAAAAAAOCAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fSmFuZyBldCBhbCAyMDIyIC0gI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIA3S86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpKYW5nIGV0IGFsIDIwMjIgLSBNxZNiaXVzIE1ldGFwcm9ncmFtbWluZyBVc2luZyBDb250ZXh0dWFsIFR5cGVzIFRoZSBTdGFnZSB3aGVyZSBTeXN0ZW0gRiBDYW4gUGF0dGVybiBNYXRjaCBvbiBJdHNlbGYucGRmAAAOAPIAeABKAGEAbgBnACAAZQB0ACAAYQBsACAAMgAwADIAMgAgAC0AIABNAVMAYgBpAHUAcwAgAE0AZQB0AGEAcAByAG8AZwByAGEAbQBtAGkAbgBnACAAVQBzAGkAbgBnACAAQwBvAG4AdABlAHgAdAB1AGEAbAAgAFQAeQBwAGUAcwAgAFQAaABlACAAUwB0AGEAZwBlACAAdwBoAGUAcgBlACAAUwB5AHMAdABlAG0AIABGACAAQwBhAG4AIABQAGEAdAB0AGUAcgBuACAATQBhAHQAYwBoACAAbwBuACAASQB0AHMAZQBsAGYALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASANtVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0phbmcgZXQgYWwgMjAyMiAtIE3Fk2JpdXMgTWV0YXByb2dyYW1taW5nIFVzaW5nIENvbnRleHR1YWwgVHlwZXMgVGhlIFN0YWdlIHdoZXJlIFN5c3RlbSBGIENhbiBQYXR0ZXJuIE1hdGNoIG9uIEl0c2VsZi5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAd8AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAFZQ==}}

@article{Allais-binding-syntax-universe-JFP,
	abstract = {The syntax of almost every programming language includes a notion of binder and corresponding bound occurrences, along with the accompanying notions of $\alpha$-equivalence, capture-avoiding substitution, typing contexts, runtime environments, and so on. In the past, implementing and reasoning about programming languages required careful handling to maintain the correct behaviour of bound variables. Modern programming languages include features that enable constraints like scope safety to be expressed in types. Nevertheless, the programmer is still forced to write the same boilerplate over again for each new implementation of a scope-safe operation (e.g., renaming, substitution, desugaring, printing), and then again for correctness proofs. We present an expressive universe of syntaxes with binding and demonstrate how to (1) implement scope-safe traversals once and for all by generic programming; and (2) how to derive properties of these traversals by generic proving. Our universe description, generic traversals and proofs, and our examples have all been formalised in Agda and are available in the accompanying material available online at https://github.com/gallais/generic-syntax.},
	author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1017/S0956796820000076},
	journal = {Journal of Functional Programming},
	pages = {e22:1-51},
	title = {A Type- and Scope-Safe Universe of Syntaxes with Binding: Their Semantics and Proofs},
	volume = {31},
	year = {2021},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxDPLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsbGFpcyBldCBhbCAyMDIxIC0gQSBUeXBlLSBhbmQgU2NvcGUtU2FmZSBVbml2ZXJzZSBvZiBTeW50YXhlcyB3aXRoIEJpbmRpbmcgVGhlaXIgU2VtYW50aWNzIGFuZCBQcm9vZnMucGRmTxEDTAAAAAADTAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0FsbGFpcyBldCBhbCAyMDIxICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAM8vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QWxsYWlzIGV0IGFsIDIwMjEgLSBBIFR5cGUtIGFuZCBTY29wZS1TYWZlIFVuaXZlcnNlIG9mIFN5bnRheGVzIHdpdGggQmluZGluZyBUaGVpciBTZW1hbnRpY3MgYW5kIFByb29mcy5wZGYAAA4A2ABrAEEAbABsAGEAaQBzACAAZQB0ACAAYQBsACAAMgAwADIAMQAgAC0AIABBACAAVAB5AHAAZQAtACAAYQBuAGQAIABTAGMAbwBwAGUALQBTAGEAZgBlACAAVQBuAGkAdgBlAHIAcwBlACAAbwBmACAAUwB5AG4AdABhAHgAZQBzACAAdwBpAHQAaAAgAEIAaQBuAGQAaQBuAGcAIABUAGgAZQBpAHIAIABTAGUAbQBhAG4AdABpAGMAcwAgAGEAbgBkACAAUAByAG8AbwBmAHMALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAM1Vc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsbGFpcyBldCBhbCAyMDIxIC0gQSBUeXBlLSBhbmQgU2NvcGUtU2FmZSBVbml2ZXJzZSBvZiBTeW50YXhlcyB3aXRoIEJpbmRpbmcgVGhlaXIgU2VtYW50aWNzIGFuZCBQcm9vZnMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAD2AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABEY=}}

@inproceedings{Pickering-staged-SoP,
	abstract = {Generic programming libraries have historically traded efficiency in return for convenience, and the \textsf{generics-sop} library is no exception. It offers a simple, uniform, representation of all datatypes precisely as a sum of products, making it easy to write generic functions. We show how to finally make \textsf{generics-sop} fast through the use of staging with Typed Template Haskell.},
	author = {Pickering, Matthew and L{\"o}h, Andres and Wu, Nicolas},
	booktitle = {International Symposium on Haskell},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3406088.3409021},
	pages = {122-135},
	publisher = {ACM},
	title = {Staged Sums of Products},
	year = {2020},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCWLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1BpY2tlcmluZyBldCBhbCAyMDIwIC0gU3RhZ2VkIFN1bXMgb2YgUHJvZHVjdHMucGRmTxECZgAAAAACZgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1BpY2tlcmluZyBldCBhbCAyMCNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJYvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6UGlja2VyaW5nIGV0IGFsIDIwMjAgLSBTdGFnZWQgU3VtcyBvZiBQcm9kdWN0cy5wZGYADgBmADIAUABpAGMAawBlAHIAaQBuAGcAIABlAHQAIABhAGwAIAAyADAAMgAwACAALQAgAFMAdABhAGcAZQBkACAAUwB1AG0AcwAgAG8AZgAgAFAAcgBvAGQAdQBjAHQAcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAlFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvUGlja2VyaW5nIGV0IGFsIDIwMjAgLSBTdGFnZWQgU3VtcyBvZiBQcm9kdWN0cy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAvQAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAMn}}

@inproceedings{Ringer-ornaments-Coq,
	abstract = {Ornaments express relations between inductive types with the same inductive structure. We implement fully automatic proof reuse for a particular class of ornaments in a Coq plugin, and show how such a tool can give programmers the rewards of using indexed inductive types while automating away many of the costs. The plugin works directly on Coq code; it is the first ornamentation tool for a non-embedded dependently typed language. It is also the first tool to automatically identify ornaments: To lift a function or proof, the user must provide only the source type, the destination type, and the source function or proof. In taking advantage of the mathematical properties of ornaments, our approach produces faster functions and smaller terms than a more general approach to proof reuse in Coq.},
	annote = {Keywords: ornaments, proof reuse, proof automation},
	author = {Ringer, Talia and Yazdani, Nathaniel and Leo, John and Grossman, Dan},
	booktitle = {International Conference on Interactive Theorem Proving (ITP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-06-30 17:16:06 +0800},
	doi = {10.4230/LIPIcs.ITP.2019.26},
	pages = {26:1-19},
	publisher = {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
	series = {Leibniz International Proceedings in Informatics (LIPIcs)},
	title = {Ornaments for Proof Reuse in {Coq}},
	urn = {urn:nbn:de:0030-drops-110816},
	volume = {141},
	year = {2019},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCcLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1JpbmdlciBldCBhbCAyMDE5IC0gT3JuYW1lbnRzIGZvciBQcm9vZiBSZXVzZSBpbiBDb3EucGRmTxECfgAAAAACfgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1JpbmdlciBldCBhbCAyMDE5ICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6UmluZ2VyIGV0IGFsIDIwMTkgLSBPcm5hbWVudHMgZm9yIFByb29mIFJldXNlIGluIENvcS5wZGYADgByADgAUgBpAG4AZwBlAHIAIABlAHQAIABhAGwAIAAyADAAMQA5ACAALQAgAE8AcgBuAGEAbQBlAG4AdABzACAAZgBvAHIAIABQAHIAbwBvAGYAIABSAGUAdQBzAGUAIABpAG4AIABDAG8AcQAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAmlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvUmluZ2VyIGV0IGFsIDIwMTkgLSBPcm5hbWVudHMgZm9yIFByb29mIFJldXNlIGluIENvcS5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAwwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANF}}

@inproceedings{Chen-Mtac-Agda,
	abstract = {We present a work in progress---a shallow embedding of a typed tactic language \emph{Mtac} using \emph{elaborator reflection} in a dependently typed language to allow users to write high-level tactics within the same language. In contrast to the original implementation of Mtac in Coq, this implementation is completely written in Agda using its reflection mechanism. To focus on the difference from its Coq counterpart, we give an example of tactics and briefly sketch the implementation of the core design and the pattern matching construct.},
	author = {Chen, Liang-Ting},
	booktitle = {Workshop on Type-Driven Development (TyDe)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-02-03 10:44:36 +0800},
	title = {Monadic Typed Tactic Programming by Reflection (Extended Abstract)},
	url = {https://tydeworkshop.org/2019-abstracts/paper20.pdf},
	year = {2019},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC2Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoZW4gMjAxOSAtIE1vbmFkaWMgVHlwZWQgVGFjdGljIFByb2dyYW1taW5nIGJ5IFJlZmxlY3Rpb24gKGV4dGVuZGVkIGFic3RyYWN0KS5wZGZPEQLmAAAAAALmAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fQ2hlbiAyMDE5IC0gTW9uYWRpI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAti86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpDaGVuIDIwMTkgLSBNb25hZGljIFR5cGVkIFRhY3RpYyBQcm9ncmFtbWluZyBieSBSZWZsZWN0aW9uIChleHRlbmRlZCBhYnN0cmFjdCkucGRmAA4ApgBSAEMAaABlAG4AIAAyADAAMQA5ACAALQAgAE0AbwBuAGEAZABpAGMAIABUAHkAcABlAGQAIABUAGEAYwB0AGkAYwAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGIAeQAgAFIAZQBmAGwAZQBjAHQAaQBvAG4AIAAoAGUAeAB0AGUAbgBkAGUAZAAgAGEAYgBzAHQAcgBhAGMAdAApAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgC0VXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9DaGVuIDIwMTkgLSBNb25hZGljIFR5cGVkIFRhY3RpYyBQcm9ncmFtbWluZyBieSBSZWZsZWN0aW9uIChleHRlbmRlZCBhYnN0cmFjdCkucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAN0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADxw==}}

@inproceedings{Allais-n-ary-functions,
	abstract = {Agda's standard library struggles in various places with n-ary functions and relations. It introduces congruence and substitution operators for functions of arities one and two, and provides users with convenient combinators for manipulating indexed families of arity exactly one.\par

After a careful analysis of the kinds of problems the unifier can easily solve, we design a unifier-friendly representation of n-ary functions. This allows us to write generic programs acting on n-ary functions which automatically reconstruct the representation of their inputs' types by unification. In particular, we can define fully level polymorphic n-ary versions of congruence, substitution and the combinators for indexed families, all requiring minimal user input.},
	author = {Allais, Guillaume},
	booktitle = {Workshop on Type-Driven Development (TyDe)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3331554.3342604},
	pages = {14--26},
	publisher = {ACM},
	title = {Generic Level Polymorphic N-ary Functions},
	year = 2019,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCfLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsbGFpcyAyMDE5IC0gR2VuZXJpYyBMZXZlbCBQb2x5bW9ycGhpYyBOLWFyeSBGdW5jdGlvbnMucGRmTxECjAAAAAACjAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0FsbGFpcyAyMDE5IC0gR2VuZSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJ8vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QWxsYWlzIDIwMTkgLSBHZW5lcmljIExldmVsIFBvbHltb3JwaGljIE4tYXJ5IEZ1bmN0aW9ucy5wZGYAAA4AeAA7AEEAbABsAGEAaQBzACAAMgAwADEAOQAgAC0AIABHAGUAbgBlAHIAaQBjACAATABlAHYAZQBsACAAUABvAGwAeQBtAG8AcgBwAGgAaQBjACAATgAtAGEAcgB5ACAARgB1AG4AYwB0AGkAbwBuAHMALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJ1Vc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsbGFpcyAyMDE5IC0gR2VuZXJpYyBMZXZlbCBQb2x5bW9ycGhpYyBOLWFyeSBGdW5jdGlvbnMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADGAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA1Y=}}

@article{Williams-principle-ornamentation,
	abstract = {Ornaments are a way to describe changes in datatype definitions reorganizing, adding, or dropping some pieces of data so that functions operating on the bare definition can be partially and sometimes totally lifted into functions operating on the ornamented structure. We propose an extension of ML with higher-order ornaments, demonstrate its expressiveness with a few typical examples, including code refactoring, study the metatheoretical properties of ornaments, and describe their elaboration process. We formalize ornamentation via an a posteriori abstraction of the bare code, returning a generic term, which lives in a meta-language above ML. The lifted code is obtained by application of the generic term to well-chosen arguments, followed by staged reduction, and some remaining simplifications. We use logical relations to closely relate the lifted code to the bare code.},
	author = {Williams, Thomas and R{\'e}my, Didier},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-03-03 17:34:10 +0800},
	doi = {10.1145/3158109},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {21:1--30},
	title = {A Principled Approach to Ornamentation in {ML}},
	volume = {2},
	year = {2018},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCqLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1dpbGxpYW1zIGV0IGFsIDIwMTggLSBBIFByaW5jaXBsZWQgQXBwcm9hY2ggdG8gT3JuYW1lbnRhdGlvbiBpbiBNTC5wZGZPEQK2AAAAAAK2AAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fV2lsbGlhbXMgZXQgYWwgMjAxI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAqi86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpXaWxsaWFtcyBldCBhbCAyMDE4IC0gQSBQcmluY2lwbGVkIEFwcHJvYWNoIHRvIE9ybmFtZW50YXRpb24gaW4gTUwucGRmAA4AjgBGAFcAaQBsAGwAaQBhAG0AcwAgAGUAdAAgAGEAbAAgADIAMAAxADgAIAAtACAAQQAgAFAAcgBpAG4AYwBpAHAAbABlAGQAIABBAHAAcAByAG8AYQBjAGgAIAB0AG8AIABPAHIAbgBhAG0AZQBuAHQAYQB0AGkAbwBuACAAaQBuACAATQBMAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCoVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9XaWxsaWFtcyBldCBhbCAyMDE4IC0gQSBQcmluY2lwbGVkIEFwcHJvYWNoIHRvIE9ybmFtZW50YXRpb24gaW4gTUwucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkANEAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADiw==}}

@article{Kiselyov-MetaOCaml,
	abstract = {A common application of generative programming is building high-performance computational kernels highly tuned to the problem at hand. A typical linear algebra kernel is specialized to the numerical domain (rational, float, double, etc.), loop unrolling factors, array layout and a priori knowledge (e.g., the matrix being positive definite). It is tedious and error prone to specialize by hand, writing numerous variations of the same algorithm.\par

The widely used generators such as ATLAS and SPIRAL reliably produce highly tuned specialized code but are difficult to extend. In ATLAS, which generates code using printf, even balancing parentheses is a challenge. According to the ATLAS creator, debugging is nightmare.\par

A typed staged programming language such as MetaOCaml lets us state a general, obviously correct algorithm and add layers of specializations in a modular way. By ensuring that the generated code always compiles and letting us quickly test it, MetaOCaml makes writing generators less daunting and more productive. The readers will see it for themselves in this hands-on tutorial. Assuming no prior knowledge of MetaOCaml and only a basic familiarity with functional programming, we will eventually implement a simple domain-specific language (DSL) for linear algebra, with layers of optimizations for sparsity and memory layout of matrices and vectors, and their algebraic properties. We will generate optimal BLAS kernels. We shall get the taste of the ``Abstraction without guilt''.},
	author = {Kiselyov, Oleg},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1561/2500000038},
	journal = {Foundations and Trends in Programming Languages},
	number = {1},
	pages = {1-101},
	title = {Reconciling Abstraction with High Performance: A {MetaOCaml} Approach},
	volume = {5},
	year = {2018},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC6Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tpc2VseW92IDIwMTggLSBSZWNvbmNpbGluZyBBYnN0cmFjdGlvbiB3aXRoIEhpZ2ggUGVyZm9ybWFuY2UgQSBNZXRhT0NhbWwgQXBwcm9hY2gucGRmTxEC9gAAAAAC9gACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0tpc2VseW92IDIwMTggLSBSZSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACALovOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6S2lzZWx5b3YgMjAxOCAtIFJlY29uY2lsaW5nIEFic3RyYWN0aW9uIHdpdGggSGlnaCBQZXJmb3JtYW5jZSBBIE1ldGFPQ2FtbCBBcHByb2FjaC5wZGYADgCuAFYASwBpAHMAZQBsAHkAbwB2ACAAMgAwADEAOAAgAC0AIABSAGUAYwBvAG4AYwBpAGwAaQBuAGcAIABBAGIAcwB0AHIAYQBjAHQAaQBvAG4AIAB3AGkAdABoACAASABpAGcAaAAgAFAAZQByAGYAbwByAG0AYQBuAGMAZQAgAEEAIABNAGUAdABhAE8AQwBhAG0AbAAgAEEAcABwAHIAbwBhAGMAaAAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAuFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvS2lzZWx5b3YgMjAxOCAtIFJlY29uY2lsaW5nIEFic3RyYWN0aW9uIHdpdGggSGlnaCBQZXJmb3JtYW5jZSBBIE1ldGFPQ2FtbCBBcHByb2FjaC5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQA4QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAPb}}

@article{Yallop-staged-generic-programming,
	abstract = {Generic programming libraries such as \textit{Scrap Your Boilerplate} eliminate the need to write repetitive code, but typically introduce significant performance overheads. This leaves programmers with the regrettable choice between writing succinct but slow programs and writing tedious but efficient programs.\par

Applying structured multi-stage programming techniques transforms \emph{Scrap Your Boilerplate} from an inefficient library into a typed optimising code generator, bringing its performance in line with hand-written code, and so combining high-level programming with uncompromised performance.},
	author = {Yallop, Jeremy},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3110273},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {ICFP},
	pages = {29:1--29},
	title = {Staged Generic Programming},
	volume = {1},
	year = 2017,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCQLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1lhbGxvcCAyMDE3IC0gU3RhZ2VkIEdlbmVyaWMgUHJvZ3JhbW1pbmcucGRmTxECTgAAAAACTgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1lhbGxvcCAyMDE3IC0gU3RhZyNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJAvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6WWFsbG9wIDIwMTcgLSBTdGFnZWQgR2VuZXJpYyBQcm9ncmFtbWluZy5wZGYADgBaACwAWQBhAGwAbABvAHAAIAAyADAAMQA3ACAALQAgAFMAdABhAGcAZQBkACAARwBlAG4AZQByAGkAYwAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAjlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvWWFsbG9wIDIwMTcgLSBTdGFnZWQgR2VuZXJpYyBQcm9ncmFtbWluZy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAtwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAMJ}}

@article{Ko-OrnJFP,
	abstract = {Dependently typed programming advocates the use of various indexed versions of the same shape of data, but the formal relationship amongst these structurally similar datatypes usually needs to be established manually and tediously. Ornaments have been proposed as a formal mechanism to manage the relationships between such datatype variants. In this paper, we conduct a case study under an ornament framework; the case study concerns programming binomial heaps and their operations --- including insertion and minimum extraction --- by viewing them as lifted versions of binary numbers and numeric operations. We show how current dependently typed programming technology can lead to a clean treatment of the binomial heap constraints when implementing heap operations. We also identify some gaps between the current technology and an ideal dependently typed programming language that we would wish to have for our development.},
	author = {Ko, Hsiang-Shang and Gibbons, Jeremy},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1017/S0956796816000307},
	journal = {Journal of Functional Programming},
	pages = {e2:1-43},
	title = {Programming with Ornaments},
	volume = {27},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCSLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTcgLSBQcm9ncmFtbWluZyB3aXRoIE9ybmFtZW50cy5wZGZPEQJWAAAAAAJWAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fS28gZXQgYWwgMjAxNyAtIFByI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAki86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpLbyBldCBhbCAyMDE3IC0gUHJvZ3JhbW1pbmcgd2l0aCBPcm5hbWVudHMucGRmAA4AXgAuAEsAbwAgAGUAdAAgAGEAbAAgADIAMAAxADcAIAAtACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAdwBpAHQAaAAgAE8AcgBuAGEAbQBlAG4AdABzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCQVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDE3IC0gUHJvZ3JhbW1pbmcgd2l0aCBPcm5hbWVudHMucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALkAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADEw==}}

@inproceedings{Christiansen-elaborator-reflection,
	abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe \emph{elaborator reflection}, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris's reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.},
	author = {Christiansen, David and Brady, Edwin},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/3022670.2951932},
	pages = {284-297},
	publisher = {ACM},
	title = {Elaborator Reflection: Extending {Idris} in {Idris}},
	year = {2016},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCwLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NocmlzdGlhbnNlbiBldCBhbCAyMDE2IC0gRWxhYm9yYXRvciBSZWZsZWN0aW9uIEV4dGVuZGluZyBJZHJpcyBpbiBJZHJpcy5wZGZPEQLOAAAAAALOAAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fQ2hyaXN0aWFuc2VuIGV0IGFsI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAsC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpDaHJpc3RpYW5zZW4gZXQgYWwgMjAxNiAtIEVsYWJvcmF0b3IgUmVmbGVjdGlvbiBFeHRlbmRpbmcgSWRyaXMgaW4gSWRyaXMucGRmAA4AmgBMAEMAaAByAGkAcwB0AGkAYQBuAHMAZQBuACAAZQB0ACAAYQBsACAAMgAwADEANgAgAC0AIABFAGwAYQBiAG8AcgBhAHQAbwByACAAUgBlAGYAbABlAGMAdABpAG8AbgAgAEUAeAB0AGUAbgBkAGkAbgBnACAASQBkAHIAaQBzACAAaQBuACAASQBkAHIAaQBzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCuVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9DaHJpc3RpYW5zZW4gZXQgYWwgMjAxNiAtIEVsYWJvcmF0b3IgUmVmbGVjdGlvbiBFeHRlbmRpbmcgSWRyaXMgaW4gSWRyaXMucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkANcAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADqQ==}}

@inproceedings{Williams-ornaments-in-practice,
	abstract = {Ornaments have been introduced as a way to describe some changes in datatype definitions that preserve their recursive structure, reorganizing, adding, or dropping some pieces of data. After a new data structure has been described as an ornament of older one, some functions operating on the bare structure can be partially or sometimes totally lifted into functions operating on the ornamented structure. We explore the feasibility and the interest of using ornaments in practice by applying these notions in an ML-like programming language. We propose a concrete syntax for defining ornaments of datatypes and the lifting of bare functions to their ornamented counterparts, describe the lifting process, and present several interesting use cases of ornaments.},
	author = {Williams, Thomas and Dagand, Pierre-{\'E}variste and R{\'e}my, Didier},
	booktitle = {Workshop on Generic Programming (WGP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/2633628.2633631},
	pages = {15-24},
	publisher = {ACM},
	title = {Ornaments in Practice},
	year = {2014},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCTLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1dpbGxpYW1zIGV0IGFsIDIwMTQgLSBPcm5hbWVudHMgaW4gUHJhY3RpY2UucGRmTxECXAAAAAACXAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1dpbGxpYW1zIGV0IGFsIDIwMSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJMvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6V2lsbGlhbXMgZXQgYWwgMjAxNCAtIE9ybmFtZW50cyBpbiBQcmFjdGljZS5wZGYAAA4AYAAvAFcAaQBsAGwAaQBhAG0AcwAgAGUAdAAgAGEAbAAgADIAMAAxADQAIAAtACAATwByAG4AYQBtAGUAbgB0AHMAIABpAG4AIABQAHIAYQBjAHQAaQBjAGUALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJFVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1dpbGxpYW1zIGV0IGFsIDIwMTQgLSBPcm5hbWVudHMgaW4gUHJhY3RpY2UucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAC6AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAxo=}}

@inproceedings{de-Vries-true-SoP,
	abstract = {We introduce the \emph{sum-of-products} (SOP) view for datatype-generic programming (in Haskell). While many of the libraries that are commonly in use today represent datatypes as arbitrary combinations of binary sums and products, SOP reflects the structure of datatypes more faithfully: each datatype is a \emph{single} $n$-ary sum, where each component of the sum is a \emph{single} $n$-ary product. This representation turns out to be expressible accurately in GHC with today's extensions. The resulting list-like structure of datatypes allows for the definition of powerful high-level traversal combinators, which in turn encourage the definition of generic functions in a compositional and concise style. A major plus of the SOP view is that it allows to separate function-specific metadata from the main structural representation and recombining this information later.},
	author = {de Vries, Edsko and L{\"o}h, Andres},
	booktitle = {Workshop on Generic Programming (WGP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/2633628.2633634},
	pages = {83-94},
	publisher = {ACM},
	title = {True Sums of Products},
	year = 2014,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCQLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1ZyaWVzIGV0IGFsIDIwMTQgLSBUcnVlIFN1bXMgb2YgUHJvZHVjdHMucGRmTxECTgAAAAACTgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1ZyaWVzIGV0IGFsIDIwMTQgLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJAvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6VnJpZXMgZXQgYWwgMjAxNCAtIFRydWUgU3VtcyBvZiBQcm9kdWN0cy5wZGYADgBaACwAVgByAGkAZQBzACAAZQB0ACAAYQBsACAAMgAwADEANAAgAC0AIABUAHIAdQBlACAAUwB1AG0AcwAgAG8AZgAgAFAAcgBvAGQAdQBjAHQAcwAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAjlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvVnJpZXMgZXQgYWwgMjAxNCAtIFRydWUgU3VtcyBvZiBQcm9kdWN0cy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAtwAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAMJ}}

@inproceedings{McBride-pivotal,
	abstract = {I present a datatype-generic treatment of recursive container types whose elements are guaranteed to be stored in increasing order, with the ordering invariant rolled out systematically. Intervals, lists and binary search trees are instances of the generic treatment. On the journey to this treatment, I report a variety of failed experiments and the transferable learning experiences they triggered. I demonstrate that a \emph{total} element ordering is enough to deliver insertion and flattening algorithms, and show that (with care about the formulation of the types) the implementations remain as usual. Agda's \emph{instance arguments} and \emph{pattern synonyms} maximize the proof search done by the typechecker and minimize the appearance of proofs in program text, often eradicating them entirely. Generalizing to indexed recursive container types, invariants such as \emph{size} and \emph{balance} can be expressed in addition to ordering. By way of example, I implement insertion and deletion for 2-3 trees, ensuring both order and balance by the discipline of type checking.},
	author = {McBride, Conor},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/2628136.2628163},
	pages = {297-309},
	publisher = {ACM},
	title = {How to Keep Your Neighbours in Order},
	year = {2014},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCbLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jQnJpZGUgMjAxNCAtIEhvdyB0byBLZWVwIFlvdXIgTmVpZ2hib3VycyBpbiBPcmRlci5wZGZPEQJ8AAAAAAJ8AAIAAAZTeXN0ZW0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQkQAAf////8fTWNCcmlkZSAyMDE0IC0gSG93I0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAFAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAmy86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNY0JyaWRlIDIwMTQgLSBIb3cgdG8gS2VlcCBZb3VyIE5laWdoYm91cnMgaW4gT3JkZXIucGRmAAAOAHAANwBNAGMAQgByAGkAZABlACAAMgAwADEANAAgAC0AIABIAG8AdwAgAHQAbwAgAEsAZQBlAHAAIABZAG8AdQByACAATgBlAGkAZwBoAGIAbwB1AHIAcwAgAGkAbgAgAE8AcgBkAGUAcgAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAmVVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTWNCcmlkZSAyMDE0IC0gSG93IHRvIEtlZXAgWW91ciBOZWlnaGJvdXJzIGluIE9yZGVyLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQAwgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANC}}

@article{Dagand-functional-ornaments,
	abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of datatypes: We can finally write correct-by-construction software. However, this extreme accuracy is also a curse: A datatype is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any attempt to reuse code across similarly structured data. In this paper, we capitalise on the structural invariants of datatypes. To do so, we first adapt the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornaments, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: The users can ask the definition of addition to be lifted to lists and they will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in the type theory with a universe of datatypes and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
	author = {Dagand, Pierre-{\'E}variste and McBride, Conor},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1017/S0956796814000069},
	journal = {Journal of Functional Programming},
	number = {2--3},
	pages = {316-383},
	read = {1},
	title = {Transporting Functions across Ornaments},
	volume = {24},
	year = {2014},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCjLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZk8RApwAAAAAApwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9EYWdhbmQgZXQgYWwgMjAxNCAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCjLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkRhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZgAADgCAAD8ARABhAGcAYQBuAGQAIABlAHQAIABhAGwAIAAyADAAMQA0ACAALQAgAFQAcgBhAG4AcwBwAG8AcgB0AGkAbgBnACAARgB1AG4AYwB0AGkAbwBuAHMAIABhAGMAcgBvAHMAcwAgAE8AcgBuAGEAbQBlAG4AdABzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgChVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9EYWdhbmQgZXQgYWwgMjAxNCAtIFRyYW5zcG9ydGluZyBGdW5jdGlvbnMgYWNyb3NzIE9ybmFtZW50cy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAMoAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADag==}}

@misc{McBride-ornaments,
	abstract = {This paper re-examines the presentation of datatypes in dependently typed languages, addressing in particular the issue of what it means for one datatype to be in various ways more informative than another. Informal human observations like `lists are natural numbers with extra decoration' and `vectors are lists indexed by length' are expressed in a first class language of \emph{ornaments} --- presentations of fancy new types based on plain old ones --- encompassing both decoration and, in the sense of Tim Freeman and Frank Pfenning (1991), refinement.\par

Each ornament adds information, so it comes with a forgetful function from fancy data back to plain, expressible as the fold of its \emph{ornamental algebra}: lists built from numbers acquire the `length' algebra. Conversely, each algebra for a datatype induces a way to index it --- an \emph{algebraic ornament}. The length algebra for lists induces the construction of the paradigmatic dependent vector types.\par

Dependent types thus provide not only a new `axis of diversity' --- indexing --- for data structures, but also new abstractions to manage and exploit that diversity. In the spirit of `the new programming' (McBride \& McKinna, 2004), the engineering of coincidence is replaced by the propagation of consequence.},
	author = {Conor McBride},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	read = {1},
	title = {Ornamental Algebras, Algebraic Ornaments},
	url = {https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf},
	year = {2011},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCfLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jQnJpZGUgMjAxMSAtIE9ybmFtZW50YWwgQWxnZWJyYXMsIEFsZ2VicmFpYyBPcm5hbWVudHMucGRmTxECjAAAAAACjAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H01jQnJpZGUgMjAxMSAtIE9ybiNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJ8vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWNCcmlkZSAyMDExIC0gT3JuYW1lbnRhbCBBbGdlYnJhcywgQWxnZWJyYWljIE9ybmFtZW50cy5wZGYAAA4AeAA7AE0AYwBCAHIAaQBkAGUAIAAyADAAMQAxACAALQAgAE8AcgBuAGEAbQBlAG4AdABhAGwAIABBAGwAZwBlAGIAcgBhAHMALAAgAEEAbABnAGUAYgByAGEAaQBjACAATwByAG4AYQBtAGUAbgB0AHMALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJ1Vc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jQnJpZGUgMjAxMSAtIE9ybmFtZW50YWwgQWxnZWJyYXMsIEFsZ2VicmFpYyBPcm5hbWVudHMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADGAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA1Y=}}

@inproceedings{Ko-OAOAOO,
	abstract = {Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution based on McBride's datatype ornaments, exploiting an isomorphism whose interpretation borrows ideas from realisability. Relevant properties of the operations are separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises an inductive family incorporating those constraints, the operations can be routinely upgraded to work with the synthesised inductive family.},
	author = {Ko, Hsiang-Shang and Gibbons, Jeremy},
	booktitle = {Workshop on Generic Programming (WGP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1145/2036918.2036921},
	pages = {13-24},
	publisher = {ACM},
	read = {1},
	title = {Modularising Inductive Families},
	year = {2011},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCXLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTEgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZk8RAmwAAAAAAmwAAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9LbyBldCBhbCAyMDExIC0gTW8jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OktvIGV0IGFsIDIwMTEgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZgAADgBoADMASwBvACAAZQB0ACAAYQBsACAAMgAwADEAMQAgAC0AIABNAG8AZAB1AGwAYQByAGkAcwBpAG4AZwAgAGkAbgBkAHUAYwB0AGkAdgBlACAAZgBhAG0AaQBsAGkAZQBzAC4AcABkAGYADwAOAAYAUwB5AHMAdABlAG0AEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDExIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAL4AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADLg==}}

@inproceedings{Chapman-type-theory-should-eat-itself,
	abstract = {In this paper I present a partial formalisation of a normaliser for type theory in Agda[22]; extending previous work on big-step normalisation[2,1]. The normaliser in written as an environment machine. Only the \emph{computational behaviour} of the normaliser is presented omitting details of termination.},
	author = {Chapman, James},
	booktitle = {International Workshop on Logical Frameworks and Metalanguages: Theory and Practice (LFMTP)},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1016/j.entcs.2008.12.114},
	pages = {21-36},
	publisher = {Elsevier},
	series = {Electronic Notes in Theoretical Computer Science},
	title = {Type Theory Should Eat Itself},
	volume = {228},
	year = {2009},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCULi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gMjAwOSAtIFR5cGUgVGhlb3J5IFNob3VsZCBFYXQgSXRzZWxmLnBkZk8RAl4AAAAAAl4AAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9DaGFwbWFuIDIwMDkgLSBUeXAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCULzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkNoYXBtYW4gMjAwOSAtIFR5cGUgVGhlb3J5IFNob3VsZCBFYXQgSXRzZWxmLnBkZgAOAGIAMABDAGgAYQBwAG0AYQBuACAAMgAwADAAOQAgAC0AIABUAHkAcABlACAAVABoAGUAbwByAHkAIABTAGgAbwB1AGwAZAAgAEUAYQB0ACAASQB0AHMAZQBsAGYALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAJJVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gMjAwOSAtIFR5cGUgVGhlb3J5IFNob3VsZCBFYXQgSXRzZWxmLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAC7AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAx0=}}

@mastersthesis{de-Vries-masters-thesis,
	abstract = {The Generic Haskell programming language allows functions to be defined by induction on the structure of data types. This gives rise to generic functions which can be applied to values of any conceivable data type.\par

Compiling a Generic Haskell program amounts to generating a Haskell program in which all generic functions have been translated to ordinary Haskell functions. Since the Haskell language only allows functions to be defined on the values of a data type, translating generic functions defined on the structure of data types is not straightforward.\par

The application of a generic function to a value involves specializing the function to the type of its parameter. For every distinct specialization of a generic function in a Generic Haskell program, an ordinary Haskell function is generated in the compilation process. Hence, the compilation of a generic function will typically yield several ordinary functions.\par

The current method that is used to translate specializations is rather unsophisticated. At run-time, values are frequently converted back and forth to a structural representation which simplifies the code generation process considerably. This approach is often extremely detrimental to the space and time efficiency of the generated functions.\par

In this thesis an optimization method is described which attempts to dialnate all structural conversions from the generated functions by applying partial evaluation in combination with a number of program transformations. This approach essentially evaluates all conversions in the representation of values at compile-time. The functions of the resulting optimized program approach the efficiency of hand-written Haskell functions in terms of space and time usage.\par

An implementation of the described method is included as an optimizer in the final phase of the Generic Haskell compiler.},
	author = {de Vries, Martijn},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	school = {University of Groningen},
	title = {Specializing Type-Indexed Values by Partial Evaluation},
	url = {https://fse.studenttheses.ub.rug.nl/8943/},
	year = {2004},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCrLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1ZyaWVzIDIwMDQgLSBTcGVjaWFsaXppbmcgVHlwZS1JbmRleGVkIFZhbHVlcyBieSBQYXJ0aWFsIEV2YWx1YXRpb24ucGRmTxECvAAAAAACvAACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H1ZyaWVzIDIwMDQgLSBTcGVjaSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKsvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6VnJpZXMgMjAwNCAtIFNwZWNpYWxpemluZyBUeXBlLUluZGV4ZWQgVmFsdWVzIGJ5IFBhcnRpYWwgRXZhbHVhdGlvbi5wZGYAAA4AkABHAFYAcgBpAGUAcwAgADIAMAAwADQAIAAtACAAUwBwAGUAYwBpAGEAbABpAHoAaQBuAGcAIABUAHkAcABlAC0ASQBuAGQAZQB4AGUAZAAgAFYAYQBsAHUAZQBzACAAYgB5ACAAUABhAHIAdABpAGEAbAAgAEUAdgBhAGwAdQBhAHQAaQBvAG4ALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASAKlVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1ZyaWVzIDIwMDQgLSBTcGVjaWFsaXppbmcgVHlwZS1JbmRleGVkIFZhbHVlcyBieSBQYXJ0aWFsIEV2YWx1YXRpb24ucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADSAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA5I=}}

@inproceedings{Altenkirch-GP-within-DTP,
	abstract = {We show how higher kinded generic programming can be represented faithfully within a dependently typed programming system. This development has been implemented using the \textsc{Oleg} system.\par

The present work can be seen as evidence for our thesis that extensions of type systems can be done by \emph{programming} within a dependently typed language, using data as codes for types.},
	author = {Altenkirch, Thorsten and McBride, Conor},
	booktitle = {Generic Programming},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	doi = {10.1007/978-0-387-35672-3_1},
	pages = {1-20},
	publisher = {Springer},
	read = {1},
	series = {IFIP --- The International Federation for Information Processing},
	title = {Generic Programming within Dependently Typed Programming},
	volume = {115},
	year = {2003},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC4Li4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsdGVua2lyY2ggZXQgYWwgMjAwMyAtIEdlbmVyaWMgUHJvZ3JhbW1pbmcgd2l0aGluIERlcGVuZGVudGx5IFR5cGVkIFByb2dyYW1taW5nLnBkZk8RAu4AAAAAAu4AAgAABlN5c3RlbQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCRAAB/////x9BbHRlbmtpcmNoIGV0IGFsIDIjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAUABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgC4LzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkFsdGVua2lyY2ggZXQgYWwgMjAwMyAtIEdlbmVyaWMgUHJvZ3JhbW1pbmcgd2l0aGluIERlcGVuZGVudGx5IFR5cGVkIFByb2dyYW1taW5nLnBkZgAOAKoAVABBAGwAdABlAG4AawBpAHIAYwBoACAAZQB0ACAAYQBsACAAMgAwADAAMwAgAC0AIABHAGUAbgBlAHIAaQBjACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAdwBpAHQAaABpAG4AIABEAGUAcABlAG4AZABlAG4AdABsAHkAIABUAHkAcABlAGQAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZgAPAA4ABgBTAHkAcwB0AGUAbQASALZVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0FsdGVua2lyY2ggZXQgYWwgMjAwMyAtIEdlbmVyaWMgUHJvZ3JhbW1pbmcgd2l0aGluIERlcGVuZGVudGx5IFR5cGVkIFByb2dyYW1taW5nLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJADfAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA9E=}}

@article{Davies-modal-staged-computation,
	abstract = {We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of typed $\lambda$-calculi and functional languages. We directly demonstrate the sense in which our $\lambda_e^{\to\Box}$-calculus captures staging, and also give a conservative embeddng of Nielson and Nielson's two-level functional language in our functional language Mini-ML$^\Box$, thus proving that binding-time correctness is equivalent to modal correctness on this fragment. In addition, Mini-ML$^\Box$ can also express immediate evaluation and sharing of code across multiple stages, thus supporting run-time code generation as well as partial evaluation.},
	author = {Davies, Rowan and Pfenning, Frank},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-02-03 10:41:55 +0800},
	doi = {10.1145/382780.382785},
	journal = {{Journal of the ACM}},
	number = {3},
	pages = {555-604},
	title = {A Modal Analysis of Staged Computation},
	volume = {48},
	year = {2001},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCiLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RhdmllcyBldCBhbCAyMDAxIC0gQSBNb2RhbCBBbmFseXNpcyBvZiBTdGFnZWQgQ29tcHV0YXRpb24ucGRmTxEClgAAAAAClgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0RhdmllcyBldCBhbCAyMDAxICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAKIvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6RGF2aWVzIGV0IGFsIDIwMDEgLSBBIE1vZGFsIEFuYWx5c2lzIG9mIFN0YWdlZCBDb21wdXRhdGlvbi5wZGYADgB+AD4ARABhAHYAaQBlAHMAIABlAHQAIABhAGwAIAAyADAAMAAxACAALQAgAEEAIABNAG8AZABhAGwAIABBAG4AYQBsAHkAcwBpAHMAIABvAGYAIABTAHQAYQBnAGUAZAAgAEMAbwBtAHAAdQB0AGEAdABpAG8AbgAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIAoFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvRGF2aWVzIGV0IGFsIDIwMDEgLSBBIE1vZGFsIEFuYWx5c2lzIG9mIFN0YWdlZCBDb21wdXRhdGlvbi5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAyQAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANj}}

@book{Jones-partial-evaluation,
	author = {Jones, Neil D. and Gomard, Carsten K. and Sestoft, Peter},
	date-added = {2022-01-28 18:01:47 +0800},
	date-modified = {2022-01-28 18:01:47 +0800},
	isbn = {9780130202499},
	publisher = {Prentice-Hall},
	title = {Partial Evaluation and Automatic Program Generation},
	url = {https://www.itu.dk/people/sestoft/pebook/},
	year = {1993},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCuLi4vLi4vLi4vLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0pvbmVzIGV0IGFsIDE5OTMgLSBQYXJ0aWFsIEV2YWx1YXRpb24gYW5kIEF1dG9tYXRpYyBQcm9ncmFtIEdlbmVyYXRpb24ucGRmTxECxgAAAAACxgACAAAGU3lzdGVtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEAAH/////H0pvbmVzIGV0IGFsIDE5OTMgLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAABQAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAK4vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6Sm9uZXMgZXQgYWwgMTk5MyAtIFBhcnRpYWwgRXZhbHVhdGlvbiBhbmQgQXV0b21hdGljIFByb2dyYW0gR2VuZXJhdGlvbi5wZGYADgCWAEoASgBvAG4AZQBzACAAZQB0ACAAYQBsACAAMQA5ADkAMwAgAC0AIABQAGEAcgB0AGkAYQBsACAARQB2AGEAbAB1AGEAdABpAG8AbgAgAGEAbgBkACAAQQB1AHQAbwBtAGEAdABpAGMAIABQAHIAbwBnAHIAYQBtACAARwBlAG4AZQByAGEAdABpAG8AbgAuAHAAZABmAA8ADgAGAFMAeQBzAHQAZQBtABIArFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvSm9uZXMgZXQgYWwgMTk5MyAtIFBhcnRpYWwgRXZhbHVhdGlvbiBhbmQgQXV0b21hdGljIFByb2dyYW0gR2VuZXJhdGlvbi5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQA1QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAOf}}

@phdthesis{Capriotti2017,
	abstract = {This thesis introduces the idea of two-level type theory, an extension of Martin-L$\backslash$"of type theory that adds a notion of strict equality as an internal primitive. A type theory with a strict equality alongside the more conventional form of equality, the latter being of fundamental importance for the recent innovation of homotopy type theory (HoTT), was first proposed by Voevodsky, and is usually referred to as HTS. Here, we generalise and expand this idea, by developing a semantic framework that gives a systematic account of type formers for two-level systems, and proving a conservativity result relating back to a conventional type theory like HoTT. Finally, we show how a two-level theory can be used to provide partial solutions to open problems in HoTT. In particular, we use it to construct semi-simplicial types, and lay out the foundations of an internal theory of {\$}(\backslashinfty, 1){\$}-categories.},
	author = {Capriotti, Paolo},
	date-modified = {2022-02-03 10:43:53 +0800},
	school = {University of Nottingham},
	title = {Models of Type Theory with Strict Equality},
	url = {https://arxiv.org/abs/1702.04912},
	year = {2016},
	bdsk-url-1 = {http://arxiv.org/abs/1702.04912}}

@inproceedings{Altenkirch2016d,
	abstract = {In homotopy type theory (HoTT), all constructions are necessarily stable under homotopy equivalence. This has shortcomings: for example, it is believed that it is impossible to define a type of semi-simplicial types. More generally, it is difficult and often impossible to handle towers of coherences. To address this, we propose a 2-level theory which features both strict and weak equality. This can essentially be represented as two type theories: an "outer" one, containing a strict equality type former, and an "inner" one, which is some version of HoTT. Our type theory is inspired by Voevodsky's suggestion of a homotopy type system (HTS) which currently refers to a range of ideas. A core insight of our proposal is that we do not need any form of equality reflection in order to achieve what HTS was suggested for. Instead, having unique identity proofs in the outer type theory is sufficient, and it also has the meta-theoretical advantage of not breaking decidability of type checking. The inner theory can be an easily justifiable extensions of HoTT, allowing the construction of "infinite structures" which are considered impossible in plain HoTT. Alternatively, we can set the inner theory to be exactly the current standard formulation of HoTT, in which case our system can be thought of as a type-theoretic framework for working with "schematic" definitions in HoTT. As demonstrations, we define semi-simplicial types and formalise constructions of Reedy fibrant diagrams.},
	address = {Dagstuhl, Germany},
	annote = {From Duplicate 1 (Extending Homotopy Type Theory with Strict Equality - Altenkirch, Thorsten; Capriotti, Paolo; Kraus, Nicolai)

Keywords: homotopy type theory, coherences, strict equality, homotopy type system},
	archiveprefix = {arXiv},
	arxivid = {1604.03799},
	author = {Altenkirch, Thorsten and Capriotti, Paolo and Kraus, Nicolai},
	booktitle = {25th EACSL Annual Conference on Computer Science Logic (CSL 2016)},
	date-modified = {2022-06-30 17:16:21 +0800},
	doi = {10.4230/LIPIcs.CSL.2016.21},
	editor = {Talbot, Jean-Marc and Regnier, Laurent},
	eprint = {1604.03799},
	isbn = {978-3-95977-022-4},
	issn = {1868-8969},
	keywords = {Coherences,Homotopy type system,Homotopy type theory,Strict equality},
	number = {21},
	pages = {21:1----21:17},
	publisher = {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
	series = {Leibniz International Proceedings in Informatics (LIPIcs)},
	title = {{Extending Homotopy Type Theory with Strict Equality}},
	url = {http://drops.dagstuhl.de/opus/volltexte/2016/6561},
	volume = {62},
	year = {2016},
	bdsk-url-1 = {http://drops.dagstuhl.de/opus/volltexte/2016/6561},
	bdsk-url-2 = {https://doi.org/10.4230/LIPIcs.CSL.2016.21}}

@article{Dybjer1994,
	author = {Dybjer, Peter},
	date-modified = {2022-02-17 14:55:45 +0800},
	doi = {10.1007/BF01211308},
	journal = {Formal Aspects of Computing},
	number = {4},
	pages = {440--465},
	title = {Inductive Families},
	volume = {6},
	year = {1994},
	bdsk-url-1 = {http://link.springer.com/10.1007/BF01211308},
	bdsk-url-2 = {https://doi.org/10.1007/BF01211308}}

@incollection{Dybjer1999,
	author = {Dybjer, Peter and Setzer, Anton},
	booktitle = {Typed Lambda Calculi and Applications. TLCA 1999},
	doi = {10.1007/3-540-48959-2_11},
	editor = {Girard, Jean-Yves},
	isbn = {3540657630},
	issn = {16113349},
	pages = {129--146},
	publisher = {Springer, Berlin, Heidelberg},
	series = {Lecture Notes in Computer Science},
	title = {A Finite Axiomatization of Inductive-Recursive Definitions},
	url = {http://link.springer.com/10.1007/3-540-48959-2{\_}11},
	volume = {1581},
	year = {1999},
	bdsk-url-1 = {http://link.springer.com/10.1007/3-540-48959-2%7B%5C_%7D11},
	bdsk-url-2 = {https://doi.org/10.1007/3-540-48959-2_11}}

@inproceedings{Alimarine2004,
	abstract = {Generic functions are defined by induction on the structural representation of types. As a consequence, by defining just a single generic operation, one acquires this operation over any particular type. An instance on a specific type is generated by interpretation of the type's structure. A direct translation leads to extremely inefficient code that involves many conversions between types and their structural representations. In this paper we present an optimization technique based on compile-time symbolic evaluation. We prove that the optimization removes the overhead of the generated code for a considerable class of generic functions. The proof uses typing to identify intermediate data structures that should be eliminated. In essence, the output after optimization is similar to hand-written code. {\textcopyright} Springer-Verlag 2004.},
	author = {Alimarine, Artem and Smetsers, Sjaak},
	booktitle = {International Conference on Mathematics of Program Construction (MPC)},
	date-modified = {2022-02-17 14:54:26 +0800},
	doi = {10.1007/978-3-540-27764-4_3},
	pages = {16--31},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Optimizing Generic Functions},
	volume = {3125},
	year = {2004},
	bdsk-url-1 = {http://link.springer.com/10.1007/978-3-540-27764-4%7B%5C_%7D3},
	bdsk-url-2 = {https://doi.org/10.1007/978-3-540-27764-4_3}}

@misc{Norell2016,
	author = {Norell, Ulf},
	date-modified = {2022-02-17 14:57:46 +0800},
	title = {{Agda} Reflection Overhaul},
	url = {https://lists.chalmers.se/pipermail/agda/2016/008414.html},
	year = {2016},
	bdsk-url-1 = {https://lists.chalmers.se/pipermail/agda/2016/008414.html}}

@incollection{Moura2021a,
	author = {de Moura, Leonardo and Ullrich, Sebastian},
	booktitle = {Automated Deduction -- {CADE} 28. {CADE} 2021},
	doi = {10.1007/978-3-030-79876-5_37},
	editor = {Platzer, Andr{\'{e}} and Sutcliffe, Geoff},
	isbn = {9783030798758},
	issn = {16113349},
	pages = {625--635},
	publisher = {Springer, Cham},
	series = {Lecture Notes in Computer Science},
	title = {The {Lean} 4 Theorem Prover and Programming Language},
	url = {http://dx.doi.org/10.1007/978-3-030-79876-5{\_}37 https://link.springer.com/10.1007/978-3-030-79876-5{\_}37},
	volume = {12699},
	year = {2021},
	bdsk-url-1 = {http://dx.doi.org/10.1007/978-3-030-79876-5%7B%5C_%7D37%20https://link.springer.com/10.1007/978-3-030-79876-5%7B%5C_%7D37},
	bdsk-url-2 = {http://dx.doi.org/10.1007/978-3-030-79876-5_37}}

@incollection{Kokke2015,
	author = {Kokke, Pepijn and Swierstra, Wouter},
	booktitle = {Mathematics of Program Construction. MPC 2015},
	doi = {10.1007/978-3-319-19797-5_14},
	editor = {Hinze, Ralf and Voigtl{\"{a}}nder, Janis},
	isbn = {9783319197968},
	issn = {16113349},
	pages = {276--301},
	publisher = {Springer, Cham},
	series = {Lecture Notes in Computer Science},
	title = {{Auto} in {Agda}},
	url = {http://link.springer.com/10.1007/978-3-319-19797-5{\_}14},
	volume = {9129},
	year = {2015},
	bdsk-url-1 = {http://link.springer.com/10.1007/978-3-319-19797-5%7B%5C_%7D14},
	bdsk-url-2 = {https://doi.org/10.1007/978-3-319-19797-5_14}}

@misc{Agda,
	author = {{Agda Team}, {The}},
	date-modified = {2022-02-28 10:16:59 +0800},
	howpublished = {\url{https://agda.readthedocs.io/en/v2.6.2.1/}},
	note = {Accessed: 2022-02-23},
	title = {{Agda} 2.6.2.1 Documentation},
	year = {2022}}

@misc{AgdaIssue3831,
	author = {{Agda Issue}},
	date-modified = {2022-03-03 17:27:10 +0800},
	note = {Accessed: 2022-03-02},
	title = {Wrong {de Bruijn} Indices for Reflected Variables inside an Extended Context},
	url = {https://github.com/agda/agda/issues/3831},
	year = {2019},
	bdsk-url-1 = {https://github.com/agda/agda/issues/3831}}

@misc{AgdaIssue4898,
	author = {{Agda Issue}},
	date-modified = {2022-03-03 17:26:16 +0800},
	note = {Accessed: 2022-03-02},
	title = {Get Rid of \textsc{UNREACHABLE} on Escaping Variable},
	url = {https://github.com/agda/agda/pull/4898},
	year = {2020},
	bdsk-url-1 = {https://github.com/agda/agda/pull/4898}}

@misc{AgdaIssue5810,
	author = {{Agda Issue}},
	date-modified = {2022-03-03 17:26:26 +0800},
	note = {Accessed: 2022-03-02},
	title = {Loss of Subject Reduction with Set},
	url = {https://github.com/agda/agda/issues/5810},
	year = {2022},
	bdsk-url-1 = {https://github.com/agda/agda/issues/5810}}

@article{Harper1993,
	author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon D.},
	date-modified = {2022-03-03 17:31:51 +0800},
	doi = {10.1145/138027.138060},
	journal = {{Journal of the ACM}},
	number = {1},
	pages = {143--184},
	title = {A Framework for Defining Logics},
	volume = {40},
	year = {1993},
	bdsk-url-1 = {http://portal.acm.org/citation.cfm?doid=138027.138060},
	bdsk-url-2 = {https://doi.org/10.1145/138027.138060}}

@article{Kavvos2021,
	author = {Kavvos, G. Alex},
	editor = {de Paiva, Valeria and Artemov, Sergei},
	isbn = {978-1-84890-377-7},
	issn = {2631-9810},
	journal = {Journal of Applied Logics - The IfCoLog Journal of Logics and their Applications},
	number = {8},
	pages = {2287--2311},
	publisher = {College Publications},
	title = {Intensionality, Intensional Recursion, and the {G{\"{o}}del-L{\"{o}}b} Axiom},
	url = {http://collegepublications.co.uk/ifcolog/?00050},
	volume = {8},
	year = {2021},
	bdsk-url-1 = {http://collegepublications.co.uk/ifcolog/?00050}}

@phdthesis{nordvallforsberg2013thesis,
	author = {Nordvall Forsberg, Fredrik},
	school = {Swansea University},
	title = {Inductive-inductive definitions},
	year = {2013}}

@article{Kaposi2020a,
	author = {Kaposi, Ambrus and Kov{\'{a}}cs, Andr{\'{a}}s},
	date-modified = {2022-03-03 17:32:40 +0800},
	doi = {10.23638/LMCS-16(1:10)2020},
	journal = {Logical Methods in Computer Science},
	number = {1},
	pages = {10:1--30},
	title = {Signatures and Induction Principles for Higher Inductive-Inductive Types},
	volume = {16},
	year = {2020},
	bdsk-url-1 = {https://doi.org/10.23638/LMCS-16(1:10)2020}}

@inproceedings{Schurmann2005,
	author = {Sch{\"{u}}rmann, Carsten and Poswolsky, Adam and Sarnat, Jeffrey},
	booktitle = {International Conference on Typed Lambda Calculi and Applications (TLCA)},
	date-modified = {2022-02-26 10:47:15 +0800},
	doi = {10.1007/11417170_2},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {The -Calculus. Functional Programming with Higher-Order Encodings},
	volume = {3461},
	year = {2005},
	bdsk-url-1 = {http://link.springer.com/10.1007/11417170%7B%5C_%7D2},
	bdsk-url-2 = {https://doi.org/10.1007/11417170_2}}

@article{Ziliani2015,
	author = {Ziliani, Beta and Dreyer, Derek and Krishnaswami, Neelakantan R. and Nanevski, Aleksandar and Vafeiadis, Viktor},
	date-modified = {2022-03-03 17:36:10 +0800},
	doi = {10.1017/S0956796815000118},
	journal = {Journal of Functional Programming},
	pages = {e12:1--59},
	title = {{Mtac}: A Monad for Typed Tactic Programming in {Coq}},
	volume = {25},
	year = {2015},
	bdsk-url-1 = {http://www.journals.cambridge.org/abstract%7B%5C_%7DS0956796815000118},
	bdsk-url-2 = {https://doi.org/10.1017/S0956796815000118}}

@article{Nanevski2005,
	author = {Nanevski, Aleksandar and Pfenning, Frank},
	date-modified = {2022-02-26 10:45:20 +0800},
	doi = {10.1017/S095679680500568X},
	journal = {Journal of Functional Programming},
	number = {6},
	pages = {893--939},
	title = {Staged Computation with Names and Necessity},
	volume = {15},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1017/S095679680500568X}}

@article{Cockx2020,
	abstract = {In a dependently typed language, we can guarantee correctness of our programmes by providing formal proofs. To check them, the typechecker elaborates these programs and proofs into a low-level core language. However, this core language is by nature hard to understand by mere humans, so how can we know we proved the right thing? This question occurs in particular for dependent copattern matching, a powerful language construct for writing programmes and proofs by dependent case analysis and mixed induction/coinduction. A definition by copattern matching consists of a list of clauses that are elaborated to a case tree , which can be further translated to primitive eliminators . In previous work this second step has received a lot of attention, but the first step has been mostly ignored so far. We present an algorithm elaborating definitions by dependent copattern matching to a core language with inductive data types, coinductive record types, an identity type, and constants defined by well-typed case trees. To ensure correctness, we prove that elaboration preserves the first-match semantics of the user clauses. Based on this theoretical work, we reimplement the algorithm used by Agda to check left-hand sides of definitions by pattern matching. The new implementation is at the same time more general and less complex, and fixes a number of bugs and usability issues with the old version. Thus, we take another step towards the formally verified implementation of a practical dependently typed language.},
	author = {Cockx, Jesper and Abel, Andreas M.},
	date-modified = {2022-03-03 17:29:31 +0800},
	doi = {10.1017/S0956796819000182},
	journal = {Journal of Functional Programming},
	pages = {e2:1--43},
	title = {Elaborating Dependent (Co)pattern Matching: No Pattern Left Behind},
	volume = {30},
	year = {2020},
	bdsk-url-1 = {https://www.cambridge.org/core/product/identifier/S0956796819000182/type/journal%7B%5C_%7Darticle},
	bdsk-url-2 = {https://doi.org/10.1017/S0956796819000182}}

@article{Cockx2016,
	author = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
	doi = {10.1145/3022670.2951917},
	isbn = {9781450342193},
	issn = {03621340},
	journal = {ACM SIGPLAN Notices},
	keywords = {dependent types,inductive,type theory,unification},
	month = {sep},
	number = {9},
	pages = {270--283},
	title = {Unifiers as equivalences: proof-relevant unification of dependently typed data},
	url = {http://dl.acm.org/citation.cfm?doid=3022670.2951917},
	volume = {51},
	year = {2016},
	bdsk-url-1 = {http://dl.acm.org/citation.cfm?doid=3022670.2951917},
	bdsk-url-2 = {https://doi.org/10.1145/3022670.2951917}}

@article{Cockx2018,
	author = {Cockx, Jesper and Devriese, Dominique},
	doi = {10.1017/S095679681800014X},
	isbn = {0956796818},
	issn = {0956-7968},
	journal = {Journal of Functional Programming},
	month = {may},
	number = {May 2019},
	pages = {e12},
	title = {Proof-relevant unification: Dependent pattern matching with only the axioms of your type theory},
	url = {https://www.cambridge.org/core/product/identifier/S095679681800014X/type/journal{\_}article},
	volume = {28},
	year = {2018},
	bdsk-url-1 = {https://www.cambridge.org/core/product/identifier/S095679681800014X/type/journal%7B%5C_%7Darticle},
	bdsk-url-2 = {https://doi.org/10.1017/S095679681800014X}}
